{"version":3,"file":"dom.js","sources":["../../src/animation/utils/is-dom-keyframes.ts","../../src/animation/animate/resolve-subjects.ts","../../src/animation/sequence/utils/calc-repeat-duration.ts","../../src/animation/sequence/utils/calc-time.ts","../../src/animation/sequence/utils/edit.ts","../../src/animation/sequence/utils/normalize-times.ts","../../src/animation/sequence/utils/sort.ts","../../src/animation/sequence/create.ts","../../src/render/store.ts","../../src/animation/utils/is-keyframes-target.ts","../../src/render/utils/resolve-variants.ts","../../src/render/utils/resolve-dynamic-variants.ts","../../src/render/utils/setters.ts","../../src/value/use-will-change/is.ts","../../src/value/use-will-change/add-will-change.ts","../../src/render/dom/utils/camel-to-dash.ts","../../src/animation/optimized-appear/data-id.ts","../../src/animation/optimized-appear/get-appear-id.ts","../../src/animation/animators/waapi/utils/get-final-keyframe.ts","../../src/animation/utils/default-transitions.ts","../../src/animation/utils/is-transition-defined.ts","../../src/animation/interfaces/motion-value.ts","../../src/animation/interfaces/visual-element-target.ts","../../src/projection/geometry/conversion.ts","../../src/projection/utils/measure.ts","../../src/motion/features/definitions.ts","../../src/projection/geometry/models.ts","../../src/utils/is-browser.ts","../../src/utils/reduced-motion/state.ts","../../src/utils/reduced-motion/index.ts","../../src/animation/utils/is-animation-controls.ts","../../src/render/utils/is-variant-label.ts","../../src/render/utils/variant-props.ts","../../src/render/utils/is-controlling-variants.ts","../../src/render/utils/motion-values.ts","../../src/render/VisualElement.ts","../../src/render/dom/DOMVisualElement.ts","../../src/render/html/utils/build-transform.ts","../../src/render/html/utils/build-styles.ts","../../src/render/html/utils/render.ts","../../src/projection/styles/scale-border-radius.ts","../../src/projection/styles/scale-box-shadow.ts","../../src/projection/styles/scale-correction.ts","../../src/motion/utils/is-forced-motion-value.ts","../../src/render/html/utils/scrape-motion-values.ts","../../src/render/html/HTMLVisualElement.ts","../../src/render/object/ObjectVisualElement.ts","../../src/render/svg/utils/path.ts","../../src/render/svg/utils/build-attrs.ts","../../src/render/svg/utils/camel-case-attrs.ts","../../src/render/svg/utils/is-svg-tag.ts","../../src/render/svg/utils/render.ts","../../src/render/svg/utils/scrape-motion-values.ts","../../src/render/svg/SVGVisualElement.ts","../../src/animation/utils/create-visual-element.ts","../../src/animation/animate/single-value.ts","../../src/animation/animate/subject.ts","../../src/animation/animate/sequence.ts","../../src/animation/animate/index.ts","../../src/animation/animators/waapi/animate-elements.ts","../../src/animation/animators/waapi/animate-style.ts","../../src/render/dom/scroll/info.ts","../../src/render/dom/scroll/offsets/inset.ts","../../src/render/dom/scroll/offsets/edge.ts","../../src/render/dom/scroll/offsets/offset.ts","../../src/render/dom/scroll/offsets/presets.ts","../../src/render/dom/scroll/offsets/index.ts","../../src/render/dom/scroll/on-scroll-handler.ts","../../src/render/dom/scroll/track.ts","../../src/render/dom/scroll/utils/get-timeline.ts","../../src/render/dom/scroll/attach-animation.ts","../../src/render/dom/scroll/attach-function.ts","../../src/render/dom/scroll/index.ts","../../src/render/dom/viewport/index.ts","../../src/utils/delay.ts","../../src/utils/distance.ts"],"sourcesContent":["import { DOMKeyframesDefinition } from \"motion-dom\"\n\nexport function isDOMKeyframes(\n    keyframes: unknown\n): keyframes is DOMKeyframesDefinition {\n    return typeof keyframes === \"object\" && !Array.isArray(keyframes)\n}\n","import {\n    AnimationScope,\n    DOMKeyframesDefinition,\n    SelectorCache,\n    resolveElements,\n} from \"motion-dom\"\nimport { ObjectTarget } from \"../sequence/types\"\nimport { isDOMKeyframes } from \"../utils/is-dom-keyframes\"\n\nexport function resolveSubjects<O extends {}>(\n    subject: string | Element | Element[] | NodeListOf<Element> | O | O[],\n    keyframes: DOMKeyframesDefinition | ObjectTarget<O>,\n    scope?: AnimationScope,\n    selectorCache?: SelectorCache\n) {\n    if (typeof subject === \"string\" && isDOMKeyframes(keyframes)) {\n        return resolveElements(subject, scope, selectorCache)\n    } else if (subject instanceof NodeList) {\n        return Array.from(subject)\n    } else if (Array.isArray(subject)) {\n        return subject\n    } else {\n        return [subject]\n    }\n}\n","export function calculateRepeatDuration(\n    duration: number,\n    repeat: number,\n    _repeatDelay: number\n): number {\n    return duration * (repeat + 1)\n}\n","import { SequenceTime } from \"../types\"\n\n/**\n * Given a absolute or relative time definition and current/prev time state of the sequence,\n * calculate an absolute time for the next keyframes.\n */\nexport function calcNextTime(\n    current: number,\n    next: SequenceTime,\n    prev: number,\n    labels: Map<string, number>\n): number {\n    if (typeof next === \"number\") {\n        return next\n    } else if (next.startsWith(\"-\") || next.startsWith(\"+\")) {\n        return Math.max(0, current + parseFloat(next))\n    } else if (next === \"<\") {\n        return prev\n    } else if (next.startsWith(\"<\")) {\n        return Math.max(0, prev + parseFloat(next.slice(1)))\n    } else {\n        return labels.get(next) ?? current\n    }\n}\n","import { mixNumber, UnresolvedValueKeyframe } from \"motion-dom\"\nimport { Easing, getEasingForSegment, removeItem } from \"motion-utils\"\nimport type { ValueSequence } from \"../types\"\n\nexport function eraseKeyframes(\n    sequence: ValueSequence,\n    startTime: number,\n    endTime: number\n): void {\n    for (let i = 0; i < sequence.length; i++) {\n        const keyframe = sequence[i]\n\n        if (keyframe.at > startTime && keyframe.at < endTime) {\n            removeItem(sequence, keyframe)\n\n            // If we remove this item we have to push the pointer back one\n            i--\n        }\n    }\n}\n\nexport function addKeyframes(\n    sequence: ValueSequence,\n    keyframes: UnresolvedValueKeyframe[],\n    easing: Easing | Easing[],\n    offset: number[],\n    startTime: number,\n    endTime: number\n): void {\n    /**\n     * Erase every existing value between currentTime and targetTime,\n     * this will essentially splice this timeline into any currently\n     * defined ones.\n     */\n    eraseKeyframes(sequence, startTime, endTime)\n\n    for (let i = 0; i < keyframes.length; i++) {\n        sequence.push({\n            value: keyframes[i],\n            at: mixNumber(startTime, endTime, offset[i]),\n            easing: getEasingForSegment(easing, i),\n        })\n    }\n}\n","/**\n * Take an array of times that represent repeated keyframes. For instance\n * if we have original times of [0, 0.5, 1] then our repeated times will\n * be [0, 0.5, 1, 1, 1.5, 2]. Loop over the times and scale them back\n * down to a 0-1 scale.\n */\nexport function normalizeTimes(times: number[], repeat: number): void {\n    for (let i = 0; i < times.length; i++) {\n        times[i] = times[i] / (repeat + 1)\n    }\n}\n","import { AbsoluteKeyframe } from \"../types\"\n\nexport function compareByTime(\n    a: AbsoluteKeyframe,\n    b: AbsoluteKeyframe\n): number {\n    if (a.at === b.at) {\n        if (a.value === null) return 1\n        if (b.value === null) return -1\n        return 0\n    } else {\n        return a.at - b.at\n    }\n}\n","import {\n    AnimationScope,\n    createGeneratorEasing,\n    defaultOffset,\n    DOMKeyframesDefinition,\n    AnimationOptions as DynamicAnimationOptions,\n    fillOffset,\n    GeneratorFactory,\n    isGenerator,\n    isMotionValue,\n    Transition,\n    UnresolvedValueKeyframe,\n    type AnyResolvedKeyframe,\n    type MotionValue,\n} from \"motion-dom\"\nimport {\n    Easing,\n    getEasingForSegment,\n    invariant,\n    progress,\n    secondsToMilliseconds,\n} from \"motion-utils\"\nimport { resolveSubjects } from \"../animate/resolve-subjects\"\nimport {\n    AnimationSequence,\n    At,\n    ResolvedAnimationDefinitions,\n    SequenceMap,\n    SequenceOptions,\n    ValueSequence,\n} from \"./types\"\nimport { calculateRepeatDuration } from \"./utils/calc-repeat-duration\"\nimport { calcNextTime } from \"./utils/calc-time\"\nimport { addKeyframes } from \"./utils/edit\"\nimport { normalizeTimes } from \"./utils/normalize-times\"\nimport { compareByTime } from \"./utils/sort\"\n\nconst defaultSegmentEasing = \"easeInOut\"\n\nconst MAX_REPEAT = 20\n\nexport function createAnimationsFromSequence(\n    sequence: AnimationSequence,\n    { defaultTransition = {}, ...sequenceTransition }: SequenceOptions = {},\n    scope?: AnimationScope,\n    generators?: { [key: string]: GeneratorFactory }\n): ResolvedAnimationDefinitions {\n    const defaultDuration = defaultTransition.duration || 0.3\n    const animationDefinitions: ResolvedAnimationDefinitions = new Map()\n    const sequences = new Map<Element | MotionValue, SequenceMap>()\n    const elementCache = {}\n    const timeLabels = new Map<string, number>()\n\n    let prevTime = 0\n    let currentTime = 0\n    let totalDuration = 0\n\n    /**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < sequence.length; i++) {\n        const segment = sequence[i]\n\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (typeof segment === \"string\") {\n            timeLabels.set(segment, currentTime)\n            continue\n        } else if (!Array.isArray(segment)) {\n            timeLabels.set(\n                segment.name,\n                calcNextTime(currentTime, segment.at, prevTime, timeLabels)\n            )\n            continue\n        }\n\n        let [subject, keyframes, transition = {}] = segment\n\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (transition.at !== undefined) {\n            currentTime = calcNextTime(\n                currentTime,\n                transition.at,\n                prevTime,\n                timeLabels\n            )\n        }\n\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0\n\n        const resolveValueSequence = (\n            valueKeyframes: UnresolvedValueKeyframe | UnresolvedValueKeyframe[],\n            valueTransition: Transition | DynamicAnimationOptions,\n            valueSequence: ValueSequence,\n            elementIndex = 0,\n            numSubjects = 0\n        ) => {\n            const valueKeyframesAsList = keyframesAsList(valueKeyframes)\n            const {\n                delay = 0,\n                times = defaultOffset(valueKeyframesAsList),\n                type = \"keyframes\",\n                repeat,\n                repeatType,\n                repeatDelay = 0,\n                ...remainingTransition\n            } = valueTransition\n            let { ease = defaultTransition.ease || \"easeOut\", duration } =\n                valueTransition\n\n            /**\n             * Resolve stagger() if defined.\n             */\n            const calculatedDelay =\n                typeof delay === \"function\"\n                    ? delay(elementIndex, numSubjects)\n                    : delay\n\n            /**\n             * If this animation should and can use a spring, generate a spring easing function.\n             */\n            const numKeyframes = valueKeyframesAsList.length\n            const createGenerator = isGenerator(type)\n                ? type\n                : generators?.[type || \"keyframes\"]\n\n            if (numKeyframes <= 2 && createGenerator) {\n                /**\n                 * As we're creating an easing function from a spring,\n                 * ideally we want to generate it using the real distance\n                 * between the two keyframes. However this isn't always\n                 * possible - in these situations we use 0-100.\n                 */\n                let absoluteDelta = 100\n                if (\n                    numKeyframes === 2 &&\n                    isNumberKeyframesArray(valueKeyframesAsList)\n                ) {\n                    const delta =\n                        valueKeyframesAsList[1] - valueKeyframesAsList[0]\n                    absoluteDelta = Math.abs(delta)\n                }\n\n                const springTransition = { ...remainingTransition }\n                if (duration !== undefined) {\n                    springTransition.duration = secondsToMilliseconds(duration)\n                }\n\n                const springEasing = createGeneratorEasing(\n                    springTransition,\n                    absoluteDelta,\n                    createGenerator\n                )\n\n                ease = springEasing.ease\n                duration = springEasing.duration\n            }\n\n            duration ??= defaultDuration\n\n            const startTime = currentTime + calculatedDelay\n\n            /**\n             * If there's only one time offset of 0, fill in a second with length 1\n             */\n            if (times.length === 1 && times[0] === 0) {\n                times[1] = 1\n            }\n\n            /**\n             * Fill out if offset if fewer offsets than keyframes\n             */\n            const remainder = times.length - valueKeyframesAsList.length\n            remainder > 0 && fillOffset(times, remainder)\n\n            /**\n             * If only one value has been set, ie [1], push a null to the start of\n             * the keyframe array. This will let us mark a keyframe at this point\n             * that will later be hydrated with the previous value.\n             */\n            valueKeyframesAsList.length === 1 &&\n                valueKeyframesAsList.unshift(null)\n\n            /**\n             * Handle repeat options\n             */\n            if (repeat) {\n                invariant(\n                    repeat < MAX_REPEAT,\n                    \"Repeat count too high, must be less than 20\",\n                    \"repeat-count-high\"\n                )\n\n                duration = calculateRepeatDuration(\n                    duration,\n                    repeat,\n                    repeatDelay\n                )\n\n                const originalKeyframes = [...valueKeyframesAsList]\n                const originalTimes = [...times]\n                ease = Array.isArray(ease) ? [...ease] : [ease]\n                const originalEase = [...ease]\n\n                for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {\n                    valueKeyframesAsList.push(...originalKeyframes)\n\n                    for (\n                        let keyframeIndex = 0;\n                        keyframeIndex < originalKeyframes.length;\n                        keyframeIndex++\n                    ) {\n                        times.push(\n                            originalTimes[keyframeIndex] + (repeatIndex + 1)\n                        )\n                        ease.push(\n                            keyframeIndex === 0\n                                ? \"linear\"\n                                : getEasingForSegment(\n                                      originalEase,\n                                      keyframeIndex - 1\n                                  )\n                        )\n                    }\n                }\n\n                normalizeTimes(times, repeat)\n            }\n\n            const targetTime = startTime + duration\n\n            /**\n             * Add keyframes, mapping offsets to absolute time.\n             */\n            addKeyframes(\n                valueSequence,\n                valueKeyframesAsList,\n                ease as Easing | Easing[],\n                times,\n                startTime,\n                targetTime\n            )\n\n            maxDuration = Math.max(calculatedDelay + duration, maxDuration)\n            totalDuration = Math.max(targetTime, totalDuration)\n        }\n\n        if (isMotionValue(subject)) {\n            const subjectSequence = getSubjectSequence(subject, sequences)\n            resolveValueSequence(\n                keyframes as AnyResolvedKeyframe,\n                transition,\n                getValueSequence(\"default\", subjectSequence)\n            )\n        } else {\n            const subjects = resolveSubjects(\n                subject,\n                keyframes as DOMKeyframesDefinition,\n                scope,\n                elementCache\n            )\n\n            const numSubjects = subjects.length\n\n            /**\n             * For every element in this segment, process the defined values.\n             */\n            for (\n                let subjectIndex = 0;\n                subjectIndex < numSubjects;\n                subjectIndex++\n            ) {\n                /**\n                 * Cast necessary, but we know these are of this type\n                 */\n                keyframes = keyframes as DOMKeyframesDefinition\n                transition = transition as DynamicAnimationOptions\n\n                const thisSubject = subjects[subjectIndex]\n                const subjectSequence = getSubjectSequence(\n                    thisSubject,\n                    sequences\n                )\n\n                for (const key in keyframes) {\n                    resolveValueSequence(\n                        keyframes[\n                            key as keyof typeof keyframes\n                        ] as UnresolvedValueKeyframe,\n                        getValueTransition(transition, key),\n                        getValueSequence(key, subjectSequence),\n                        subjectIndex,\n                        numSubjects\n                    )\n                }\n            }\n        }\n\n        prevTime = currentTime\n        currentTime += maxDuration\n    }\n\n    /**\n     * For every element and value combination create a new animation.\n     */\n    sequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key]\n\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime)\n\n            const keyframes: UnresolvedValueKeyframe[] = []\n            const valueOffset: number[] = []\n            const valueEasing: Easing[] = []\n\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i]\n                keyframes.push(value)\n                valueOffset.push(progress(0, totalDuration, at))\n                valueEasing.push(easing || \"easeOut\")\n            }\n\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0)\n                keyframes.unshift(keyframes[0])\n                valueEasing.unshift(defaultSegmentEasing)\n            }\n\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1)\n                keyframes.push(null)\n            }\n\n            if (!animationDefinitions.has(element)) {\n                animationDefinitions.set(element, {\n                    keyframes: {},\n                    transition: {},\n                })\n            }\n\n            const definition = animationDefinitions.get(element)!\n\n            definition.keyframes[key] = keyframes\n            definition.transition[key] = {\n                ...defaultTransition,\n                duration: totalDuration,\n                ease: valueEasing,\n                times: valueOffset,\n                ...sequenceTransition,\n            }\n        }\n    })\n\n    return animationDefinitions\n}\n\nfunction getSubjectSequence<O extends {}>(\n    subject: Element | MotionValue | O,\n    sequences: Map<Element | MotionValue | O, SequenceMap>\n): SequenceMap {\n    !sequences.has(subject) && sequences.set(subject, {})\n    return sequences.get(subject)!\n}\n\nfunction getValueSequence(name: string, sequences: SequenceMap): ValueSequence {\n    if (!sequences[name]) sequences[name] = []\n    return sequences[name]\n}\n\nfunction keyframesAsList(\n    keyframes: UnresolvedValueKeyframe | UnresolvedValueKeyframe[]\n): UnresolvedValueKeyframe[] {\n    return Array.isArray(keyframes) ? keyframes : [keyframes]\n}\n\nexport function getValueTransition(\n    transition: DynamicAnimationOptions & At,\n    key: string\n): DynamicAnimationOptions {\n    return transition && transition[key as keyof typeof transition]\n        ? {\n              ...transition,\n              ...(transition[key as keyof typeof transition] as Transition),\n          }\n        : { ...transition }\n}\n\nconst isNumber = (keyframe: unknown) => typeof keyframe === \"number\"\nconst isNumberKeyframesArray = (\n    keyframes: UnresolvedValueKeyframe[]\n): keyframes is number[] => keyframes.every(isNumber)\n","import type { VisualElement } from \"./VisualElement\"\n\nexport const visualElementStore = new WeakMap<any, VisualElement>()\n","import type {\n    UnresolvedValueKeyframe,\n    ValueKeyframesDefinition,\n} from \"motion-dom\"\n\nexport const isKeyframesTarget = (\n    v: ValueKeyframesDefinition\n): v is UnresolvedValueKeyframe[] => {\n    return Array.isArray(v)\n}\n","import type {\n    AnimationDefinition,\n    TargetAndTransition,\n    TargetResolver,\n} from \"motion-dom\"\nimport type { MotionProps } from \"../../motion/types\"\nimport { VisualElement } from \"../VisualElement\"\nimport type { ResolvedValues } from \"../types\"\n\nfunction getValueState(\n    visualElement?: VisualElement\n): [ResolvedValues, ResolvedValues] {\n    const state: [ResolvedValues, ResolvedValues] = [{}, {}]\n\n    visualElement?.values.forEach((value, key) => {\n        state[0][key] = value.get()\n        state[1][key] = value.getVelocity()\n    })\n\n    return state\n}\n\nexport function resolveVariantFromProps(\n    props: MotionProps,\n    definition: TargetAndTransition | TargetResolver,\n    custom?: any,\n    visualElement?: VisualElement\n): TargetAndTransition\nexport function resolveVariantFromProps(\n    props: MotionProps,\n    definition?: AnimationDefinition,\n    custom?: any,\n    visualElement?: VisualElement\n): undefined | TargetAndTransition\nexport function resolveVariantFromProps(\n    props: MotionProps,\n    definition?: AnimationDefinition,\n    custom?: any,\n    visualElement?: VisualElement\n) {\n    /**\n     * If the variant definition is a function, resolve.\n     */\n    if (typeof definition === \"function\") {\n        const [current, velocity] = getValueState(visualElement)\n        definition = definition(\n            custom !== undefined ? custom : props.custom,\n            current,\n            velocity\n        )\n    }\n\n    /**\n     * If the variant definition is a variant label, or\n     * the function returned a variant label, resolve.\n     */\n    if (typeof definition === \"string\") {\n        definition = props.variants && props.variants[definition]\n    }\n\n    /**\n     * At this point we've resolved both functions and variant labels,\n     * but the resolved variant label might itself have been a function.\n     * If so, resolve. This can only have returned a valid target object.\n     */\n    if (typeof definition === \"function\") {\n        const [current, velocity] = getValueState(visualElement)\n        definition = definition(\n            custom !== undefined ? custom : props.custom,\n            current,\n            velocity\n        )\n    }\n\n    return definition\n}\n","import type {\n    AnimationDefinition,\n    TargetAndTransition,\n    TargetResolver,\n} from \"motion-dom\"\nimport type { VisualElement } from \"../VisualElement\"\nimport { resolveVariantFromProps } from \"./resolve-variants\"\n\n/**\n * Resovles a variant if it's a variant resolver\n */\nexport function resolveVariant(\n    visualElement: VisualElement,\n    definition?: TargetAndTransition | TargetResolver,\n    custom?: any\n): TargetAndTransition\nexport function resolveVariant(\n    visualElement: VisualElement,\n    definition?: AnimationDefinition,\n    custom?: any\n): TargetAndTransition | undefined\nexport function resolveVariant(\n    visualElement: VisualElement,\n    definition?: AnimationDefinition,\n    custom?: any\n) {\n    const props = visualElement.getProps()\n    return resolveVariantFromProps(\n        props,\n        definition,\n        custom !== undefined ? custom : props.custom,\n        visualElement\n    )\n}\n","import type {\n    AnimationDefinition,\n    AnyResolvedKeyframe,\n    UnresolvedValueKeyframe,\n    ValueKeyframesDefinition,\n} from \"motion-dom\"\nimport { motionValue } from \"motion-dom\"\nimport { isKeyframesTarget } from \"../../animation/utils/is-keyframes-target\"\nimport type { VisualElement } from \"../VisualElement\"\nimport { resolveVariant } from \"./resolve-dynamic-variants\"\n\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\nfunction setMotionValue(\n    visualElement: VisualElement,\n    key: string,\n    value: AnyResolvedKeyframe\n) {\n    if (visualElement.hasValue(key)) {\n        visualElement.getValue(key)!.set(value)\n    } else {\n        visualElement.addValue(key, motionValue(value))\n    }\n}\n\nfunction resolveFinalValueInKeyframes(\n    v: ValueKeyframesDefinition\n): UnresolvedValueKeyframe {\n    // TODO maybe throw if v.length - 1 is placeholder token?\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v\n}\n\nexport function setTarget(\n    visualElement: VisualElement,\n    definition: AnimationDefinition\n) {\n    const resolved = resolveVariant(visualElement, definition)\n    let { transitionEnd = {}, transition = {}, ...target } = resolved || {}\n\n    target = { ...target, ...transitionEnd }\n\n    for (const key in target) {\n        const value = resolveFinalValueInKeyframes(\n            target[key as keyof typeof target] as any\n        )\n        setMotionValue(visualElement, key, value as AnyResolvedKeyframe)\n    }\n}\n","import { isMotionValue } from \"motion-dom\"\nimport { WillChange } from \"./types\"\n\nexport function isWillChangeMotionValue(value: any): value is WillChange {\n    return Boolean(isMotionValue(value) && (value as WillChange).add)\n}\n","import { MotionGlobalConfig } from \"motion-utils\"\nimport type { VisualElement } from \"../../render/VisualElement\"\nimport { isWillChangeMotionValue } from \"./is\"\n\nexport function addValueToWillChange(\n    visualElement: VisualElement,\n    key: string\n) {\n    const willChange = visualElement.getValue(\"willChange\")\n\n    /**\n     * It could be that a user has set willChange to a regular MotionValue,\n     * in which case we can't add the value to it.\n     */\n    if (isWillChangeMotionValue(willChange)) {\n        return willChange.add(key)\n    } else if (!willChange && MotionGlobalConfig.WillChange) {\n        const newWillChange = new MotionGlobalConfig.WillChange(\"auto\")\n\n        visualElement.addValue(\"willChange\", newWillChange)\n        newWillChange.add(key)\n    }\n}\n","/**\n * Convert camelCase to dash-case properties.\n */\nexport const camelToDash = (str: string) =>\n    str.replace(/([a-z])([A-Z])/gu, \"$1-$2\").toLowerCase()\n","import { camelToDash } from \"../../render/dom/utils/camel-to-dash\"\n\nexport const optimizedAppearDataId = \"framerAppearId\"\n\nexport const optimizedAppearDataAttribute =\n    \"data-\" + camelToDash(optimizedAppearDataId) as \"data-framer-appear-id\"\n","import { optimizedAppearDataAttribute } from \"./data-id\"\nimport { WithAppearProps } from \"./types\"\n\nexport function getOptimisedAppearId(\n    visualElement: WithAppearProps\n): string | undefined {\n    return visualElement.props[optimizedAppearDataAttribute]\n}\n","import { AnimationPlaybackOptions } from \"motion-dom\"\n\nconst isNotNull = (value: unknown) => value !== null\n\nexport function getFinalKeyframe<T>(\n    keyframes: T[],\n    { repeat, repeatType = \"loop\" }: AnimationPlaybackOptions,\n    finalKeyframe?: T\n): T {\n    const resolvedKeyframes = keyframes.filter(isNotNull)\n    const index =\n        repeat && repeatType !== \"loop\" && repeat % 2 === 1\n            ? 0\n            : resolvedKeyframes.length - 1\n\n    return !index || finalKeyframe === undefined\n        ? resolvedKeyframes[index]\n        : finalKeyframe\n}\n","import { transformProps, ValueAnimationOptions } from \"motion-dom\"\n\nconst underDampedSpring: Partial<ValueAnimationOptions> = {\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restSpeed: 10,\n}\n\nconst criticallyDampedSpring = (\n    target: unknown\n): Partial<ValueAnimationOptions> => ({\n    type: \"spring\",\n    stiffness: 550,\n    damping: target === 0 ? 2 * Math.sqrt(550) : 30,\n    restSpeed: 10,\n})\n\nconst keyframesTransition: Partial<ValueAnimationOptions> = {\n    type: \"keyframes\",\n    duration: 0.8,\n}\n\n/**\n * Default easing curve is a slightly shallower version of\n * the default browser easing curve.\n */\nconst ease: Partial<ValueAnimationOptions> = {\n    type: \"keyframes\",\n    ease: [0.25, 0.1, 0.35, 1],\n    duration: 0.3,\n}\n\nexport const getDefaultTransition = (\n    valueKey: string,\n    { keyframes }: ValueAnimationOptions\n): Partial<ValueAnimationOptions> => {\n    if (keyframes.length > 2) {\n        return keyframesTransition\n    } else if (transformProps.has(valueKey)) {\n        return valueKey.startsWith(\"scale\")\n            ? criticallyDampedSpring(keyframes[1])\n            : underDampedSpring\n    }\n\n    return ease\n}\n","import { type AnyResolvedKeyframe, type Transition } from \"motion-dom\"\n\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\nexport function isTransitionDefined({\n    when,\n    delay: _delay,\n    delayChildren,\n    staggerChildren,\n    staggerDirection,\n    repeat,\n    repeatType,\n    repeatDelay,\n    from,\n    elapsed,\n    ...transition\n}: Transition & { elapsed?: number; from?: AnyResolvedKeyframe }) {\n    return !!Object.keys(transition).length\n}\n","import type {\n    AnyResolvedKeyframe,\n    MotionValue,\n    StartAnimation,\n    UnresolvedKeyframes,\n    ValueTransition,\n} from \"motion-dom\"\nimport {\n    AsyncMotionValueAnimation,\n    frame,\n    getValueTransition,\n    JSAnimation,\n    makeAnimationInstant,\n    ValueAnimationOptions,\n} from \"motion-dom\"\nimport { MotionGlobalConfig, secondsToMilliseconds } from \"motion-utils\"\nimport type { VisualElement } from \"../../render/VisualElement\"\nimport { getFinalKeyframe } from \"../animators/waapi/utils/get-final-keyframe\"\nimport { getDefaultTransition } from \"../utils/default-transitions\"\nimport { isTransitionDefined } from \"../utils/is-transition-defined\"\n\nexport const animateMotionValue =\n    <V extends AnyResolvedKeyframe>(\n        name: string,\n        value: MotionValue<V>,\n        target: V | UnresolvedKeyframes<V>,\n        transition: ValueTransition & { elapsed?: number } = {},\n        element?: VisualElement<any>,\n        isHandoff?: boolean\n    ): StartAnimation =>\n    (onComplete) => {\n        const valueTransition = getValueTransition(transition, name) || {}\n\n        /**\n         * Most transition values are currently completely overwritten by value-specific\n         * transitions. In the future it'd be nicer to blend these transitions. But for now\n         * delay actually does inherit from the root transition if not value-specific.\n         */\n        const delay = valueTransition.delay || transition.delay || 0\n\n        /**\n         * Elapsed isn't a public transition option but can be passed through from\n         * optimized appear effects in milliseconds.\n         */\n        let { elapsed = 0 } = transition\n        elapsed = elapsed - secondsToMilliseconds(delay)\n\n        const options: ValueAnimationOptions = {\n            keyframes: Array.isArray(target) ? target : [null, target],\n            ease: \"easeOut\",\n            velocity: value.getVelocity(),\n            ...valueTransition,\n            delay: -elapsed,\n            onUpdate: (v) => {\n                value.set(v)\n                valueTransition.onUpdate && valueTransition.onUpdate(v)\n            },\n            onComplete: () => {\n                onComplete()\n                valueTransition.onComplete && valueTransition.onComplete()\n            },\n            name,\n            motionValue: value,\n            element: isHandoff ? undefined : element,\n        }\n\n        /**\n         * If there's no transition defined for this value, we can generate\n         * unique transition settings for this value.\n         */\n        if (!isTransitionDefined(valueTransition)) {\n            Object.assign(options, getDefaultTransition(name, options))\n        }\n\n        /**\n         * Both WAAPI and our internal animation functions use durations\n         * as defined by milliseconds, while our external API defines them\n         * as seconds.\n         */\n        options.duration &&= secondsToMilliseconds(options.duration)\n        options.repeatDelay &&= secondsToMilliseconds(options.repeatDelay)\n\n        /**\n         * Support deprecated way to set initial value. Prefer keyframe syntax.\n         */\n        if (options.from !== undefined) {\n            options.keyframes[0] = options.from as any\n        }\n\n        let shouldSkip = false\n\n        if (\n            (options as any).type === false ||\n            (options.duration === 0 && !options.repeatDelay)\n        ) {\n            makeAnimationInstant(options)\n\n            if (options.delay === 0) {\n                shouldSkip = true\n            }\n        }\n\n        if (\n            MotionGlobalConfig.instantAnimations ||\n            MotionGlobalConfig.skipAnimations\n        ) {\n            shouldSkip = true\n            makeAnimationInstant(options)\n            options.delay = 0\n        }\n\n        /**\n         * If the transition type or easing has been explicitly set by the user\n         * then we don't want to allow flattening the animation.\n         */\n        options.allowFlatten = !valueTransition.type && !valueTransition.ease\n\n        /**\n         * If we can or must skip creating the animation, and apply only\n         * the final keyframe, do so. We also check once keyframes are resolved but\n         * this early check prevents the need to create an animation at all.\n         */\n        if (shouldSkip && !isHandoff && value.get() !== undefined) {\n            const finalKeyframe = getFinalKeyframe<V>(\n                options.keyframes as V[],\n                valueTransition\n            )\n\n            if (finalKeyframe !== undefined) {\n                frame.update(() => {\n                    options.onUpdate!(finalKeyframe)\n                    options.onComplete!()\n                })\n\n                return\n            }\n        }\n\n        return valueTransition.isSync\n            ? new JSAnimation(options)\n            : new AsyncMotionValueAnimation(options)\n    }\n","import type { TargetAndTransition } from \"motion-dom\"\nimport {\n    AnimationPlaybackControlsWithThen,\n    frame,\n    getValueTransition,\n    positionalKeys,\n} from \"motion-dom\"\nimport type { AnimationTypeState } from \"../../render/utils/animation-state\"\nimport { setTarget } from \"../../render/utils/setters\"\nimport type { VisualElement } from \"../../render/VisualElement\"\nimport { addValueToWillChange } from \"../../value/use-will-change/add-will-change\"\nimport { getOptimisedAppearId } from \"../optimized-appear/get-appear-id\"\nimport { animateMotionValue } from \"./motion-value\"\nimport type { VisualElementAnimationOptions } from \"./types\"\n\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation(\n    { protectedKeys, needsAnimating }: AnimationTypeState,\n    key: string\n) {\n    const shouldBlock =\n        protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true\n\n    needsAnimating[key] = false\n    return shouldBlock\n}\n\nexport function animateTarget(\n    visualElement: VisualElement,\n    targetAndTransition: TargetAndTransition,\n    { delay = 0, transitionOverride, type }: VisualElementAnimationOptions = {}\n): AnimationPlaybackControlsWithThen[] {\n    let {\n        transition = visualElement.getDefaultTransition(),\n        transitionEnd,\n        ...target\n    } = targetAndTransition\n\n    if (transitionOverride) transition = transitionOverride\n\n    const animations: AnimationPlaybackControlsWithThen[] = []\n\n    const animationTypeState =\n        type &&\n        visualElement.animationState &&\n        visualElement.animationState.getState()[type]\n\n    for (const key in target) {\n        const value = visualElement.getValue(\n            key,\n            visualElement.latestValues[key] ?? null\n        )\n        const valueTarget = target[key as keyof typeof target]\n\n        if (\n            valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))\n        ) {\n            continue\n        }\n\n        const valueTransition = {\n            delay,\n            ...getValueTransition(transition || {}, key),\n        }\n\n        /**\n         * If the value is already at the defined target, skip the animation.\n         */\n        const currentValue = value.get()\n        if (\n            currentValue !== undefined &&\n            !value.isAnimating &&\n            !Array.isArray(valueTarget) &&\n            valueTarget === currentValue &&\n            !valueTransition.velocity\n        ) {\n            continue\n        }\n\n        /**\n         * If this is the first time a value is being animated, check\n         * to see if we're handling off from an existing animation.\n         */\n        let isHandoff = false\n        if (window.MotionHandoffAnimation) {\n            const appearId = getOptimisedAppearId(visualElement)\n\n            if (appearId) {\n                const startTime = window.MotionHandoffAnimation(\n                    appearId,\n                    key,\n                    frame\n                )\n\n                if (startTime !== null) {\n                    valueTransition.startTime = startTime\n                    isHandoff = true\n                }\n            }\n        }\n\n        addValueToWillChange(visualElement, key)\n\n        value.start(\n            animateMotionValue(\n                key,\n                value,\n                valueTarget,\n                visualElement.shouldReduceMotion && positionalKeys.has(key)\n                    ? { type: false }\n                    : valueTransition,\n                visualElement,\n                isHandoff\n            )\n        )\n\n        const animation = value.animation\n\n        if (animation) {\n            animations.push(animation)\n        }\n    }\n\n    if (transitionEnd) {\n        Promise.all(animations).then(() => {\n            frame.update(() => {\n                transitionEnd && setTarget(visualElement, transitionEnd)\n            })\n        })\n    }\n\n    return animations\n}\n","import { BoundingBox, Box, TransformPoint } from \"motion-utils\"\n\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\nexport function convertBoundingBoxToBox({\n    top,\n    left,\n    right,\n    bottom,\n}: BoundingBox): Box {\n    return {\n        x: { min: left, max: right },\n        y: { min: top, max: bottom },\n    }\n}\n\nexport function convertBoxToBoundingBox({ x, y }: Box): BoundingBox {\n    return { top: y.min, right: x.max, bottom: y.max, left: x.min }\n}\n\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\nexport function transformBoxPoints(\n    point: BoundingBox,\n    transformPoint?: TransformPoint\n) {\n    if (!transformPoint) return point\n    const topLeft = transformPoint({ x: point.left, y: point.top })\n    const bottomRight = transformPoint({ x: point.right, y: point.bottom })\n\n    return {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x,\n    }\n}\n","import { TransformPoint } from \"motion-utils\"\nimport {\n    convertBoundingBoxToBox,\n    transformBoxPoints,\n} from \"../geometry/conversion\"\nimport { translateAxis } from \"../geometry/delta-apply\"\nimport { IProjectionNode } from \"../node/types\"\n\nexport function measureViewportBox(\n    instance: HTMLElement,\n    transformPoint?: TransformPoint\n) {\n    return convertBoundingBoxToBox(\n        transformBoxPoints(instance.getBoundingClientRect(), transformPoint)\n    )\n}\n\nexport function measurePageBox(\n    element: HTMLElement,\n    rootProjectionNode: IProjectionNode,\n    transformPagePoint?: TransformPoint\n) {\n    const viewportBox = measureViewportBox(element, transformPagePoint)\n    const { scroll } = rootProjectionNode\n\n    if (scroll) {\n        translateAxis(viewportBox.x, scroll.offset.x)\n        translateAxis(viewportBox.y, scroll.offset.y)\n    }\n\n    return viewportBox\n}\n","import { MotionProps } from \"../types\"\nimport { FeatureDefinitions } from \"./types\"\n\nconst featureProps = {\n    animation: [\n        \"animate\",\n        \"variants\",\n        \"whileHover\",\n        \"whileTap\",\n        \"exit\",\n        \"whileInView\",\n        \"whileFocus\",\n        \"whileDrag\",\n    ],\n    exit: [\"exit\"],\n    drag: [\"drag\", \"dragControls\"],\n    focus: [\"whileFocus\"],\n    hover: [\"whileHover\", \"onHoverStart\", \"onHoverEnd\"],\n    tap: [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"],\n    pan: [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"],\n    inView: [\"whileInView\", \"onViewportEnter\", \"onViewportLeave\"],\n    layout: [\"layout\", \"layoutId\"],\n}\n\nexport const featureDefinitions: Partial<FeatureDefinitions> = {}\n\nfor (const key in featureProps) {\n    featureDefinitions[key as keyof typeof featureDefinitions] = {\n        isEnabled: (props: MotionProps) =>\n            featureProps[key as keyof typeof featureProps].some(\n                (name: string) => !!props[name as keyof typeof props]\n            ),\n    }\n}\n","import { Axis, AxisDelta, Box, Delta } from \"motion-utils\"\n\nexport const createAxisDelta = (): AxisDelta => ({\n    translate: 0,\n    scale: 1,\n    origin: 0,\n    originPoint: 0,\n})\n\nexport const createDelta = (): Delta => ({\n    x: createAxisDelta(),\n    y: createAxisDelta(),\n})\n\nexport const createAxis = (): Axis => ({ min: 0, max: 0 })\n\nexport const createBox = (): Box => ({\n    x: createAxis(),\n    y: createAxis(),\n})\n","export const isBrowser = typeof window !== \"undefined\"\n","interface ReducedMotionState {\n    current: boolean | null\n}\n\n// Does this device prefer reduced motion? Returns `null` server-side.\nexport const prefersReducedMotion: ReducedMotionState = { current: null }\n\nexport const hasReducedMotionListener = { current: false }\n","import { isBrowser } from \"../is-browser\"\nimport { hasReducedMotionListener, prefersReducedMotion } from \"./state\"\n\nexport function initPrefersReducedMotion() {\n    hasReducedMotionListener.current = true\n    if (!isBrowser) return\n\n    if (window.matchMedia) {\n        const motionMediaQuery = window.matchMedia(\"(prefers-reduced-motion)\")\n\n        const setReducedMotionPreferences = () =>\n            (prefersReducedMotion.current = motionMediaQuery.matches)\n\n        motionMediaQuery.addEventListener(\"change\", setReducedMotionPreferences)\n\n        setReducedMotionPreferences()\n    } else {\n        prefersReducedMotion.current = false\n    }\n}\n","import { LegacyAnimationControls } from \"motion-dom\"\n\nexport function isAnimationControls(v?: unknown): v is LegacyAnimationControls {\n    return (\n        v !== null &&\n        typeof v === \"object\" &&\n        typeof (v as LegacyAnimationControls).start === \"function\"\n    )\n}\n","/**\n * Decides if the supplied variable is variant label\n */\nexport function isVariantLabel(v: unknown): v is string | string[] {\n    return typeof v === \"string\" || Array.isArray(v)\n}\n","import { AnimationType } from \"./types\"\n\nexport const variantPriorityOrder: AnimationType[] = [\n    \"animate\",\n    \"whileInView\",\n    \"whileFocus\",\n    \"whileHover\",\n    \"whileTap\",\n    \"whileDrag\",\n    \"exit\",\n]\n\nexport const variantProps = [\"initial\", ...variantPriorityOrder]\n","import { isAnimationControls } from \"../../animation/utils/is-animation-controls\"\nimport { MotionProps } from \"../../motion/types\"\nimport { isVariantLabel } from \"./is-variant-label\"\nimport { variantProps } from \"./variant-props\"\n\nexport function isControllingVariants(props: MotionProps) {\n    return (\n        isAnimationControls(props.animate) ||\n        variantProps.some((name) =>\n            isVariantLabel(props[name as keyof typeof props])\n        )\n    )\n}\n\nexport function isVariantNode(props: MotionProps) {\n    return Boolean(isControllingVariants(props) || props.variants)\n}\n","import { isMotionValue, motionValue } from \"motion-dom\"\nimport { MotionStyle } from \"../../motion/types\"\nimport type { VisualElement } from \"../VisualElement\"\n\nexport function updateMotionValuesFromProps(\n    element: VisualElement,\n    next: MotionStyle,\n    prev: MotionStyle\n) {\n    for (const key in next) {\n        const nextValue = next[key as keyof MotionStyle]\n        const prevValue = prev[key as keyof MotionStyle]\n\n        if (isMotionValue(nextValue)) {\n            /**\n             * If this is a motion value found in props or style, we want to add it\n             * to our visual element's motion value map.\n             */\n            element.addValue(key, nextValue)\n        } else if (isMotionValue(prevValue)) {\n            /**\n             * If we're swapping from a motion value to a static value,\n             * create a new motion value from that\n             */\n            element.addValue(key, motionValue(nextValue, { owner: element }))\n        } else if (prevValue !== nextValue) {\n            /**\n             * If this is a flat value that has changed, update the motion value\n             * or create one if it doesn't exist. We only want to do this if we're\n             * not handling the value with our animation state.\n             */\n            if (element.hasValue(key)) {\n                const existingValue = element.getValue(key)!\n\n                if (existingValue.liveStyle === true) {\n                    existingValue.jump(nextValue)\n                } else if (!existingValue.hasAnimated) {\n                    existingValue.set(nextValue)\n                }\n            } else {\n                const latestValue = element.getStaticValue(key)\n                element.addValue(\n                    key,\n                    motionValue(\n                        latestValue !== undefined ? latestValue : nextValue,\n                        { owner: element }\n                    )\n                )\n            }\n        }\n    }\n\n    // Handle removed values\n    for (const key in prev) {\n        if (next[key as keyof MotionStyle] === undefined)\n            element.removeValue(key)\n    }\n\n    return next\n}\n","import {\n    cancelFrame,\n    complex,\n    findValueType,\n    frame,\n    getAnimatableNone,\n    isMotionValue,\n    KeyframeResolver,\n    microtask,\n    motionValue,\n    time,\n    transformProps,\n    type AnyResolvedKeyframe,\n    type MotionValue,\n} from \"motion-dom\"\nimport type { Box } from \"motion-utils\"\nimport {\n    isNumericalString,\n    isZeroValueString,\n    SubscriptionManager,\n    warnOnce,\n} from \"motion-utils\"\nimport {\n    MotionConfigContext,\n    ReducedMotionConfig,\n} from \"../context/MotionConfigContext\"\nimport type { PresenceContextProps } from \"../context/PresenceContext\"\nimport { featureDefinitions } from \"../motion/features/definitions\"\nimport { Feature } from \"../motion/features/Feature\"\nimport { FeatureDefinitions } from \"../motion/features/types\"\nimport { MotionProps, MotionStyle } from \"../motion/types\"\nimport { createBox } from \"../projection/geometry/models\"\nimport { IProjectionNode } from \"../projection/node/types\"\nimport { initPrefersReducedMotion } from \"../utils/reduced-motion\"\nimport {\n    hasReducedMotionListener,\n    prefersReducedMotion,\n} from \"../utils/reduced-motion/state\"\nimport { visualElementStore } from \"./store\"\nimport {\n    ResolvedValues,\n    VisualElementEventCallbacks,\n    VisualElementOptions,\n} from \"./types\"\nimport { AnimationState } from \"./utils/animation-state\"\nimport {\n    isControllingVariants as checkIsControllingVariants,\n    isVariantNode as checkIsVariantNode,\n} from \"./utils/is-controlling-variants\"\nimport { updateMotionValuesFromProps } from \"./utils/motion-values\"\nimport { resolveVariantFromProps } from \"./utils/resolve-variants\"\n\nconst propEventHandlers = [\n    \"AnimationStart\",\n    \"AnimationComplete\",\n    \"Update\",\n    \"BeforeLayoutMeasure\",\n    \"LayoutMeasure\",\n    \"LayoutAnimationStart\",\n    \"LayoutAnimationComplete\",\n] as const\n\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nexport abstract class VisualElement<\n    Instance = unknown,\n    RenderState = unknown,\n    Options extends {} = {}\n> {\n    /**\n     * VisualElements are arranged in trees mirroring that of the React tree.\n     * Each type of VisualElement has a unique name, to detect when we're crossing\n     * type boundaries within that tree.\n     */\n    abstract type: string\n\n    /**\n     * An `Array.sort` compatible function that will compare two Instances and\n     * compare their respective positions within the tree.\n     */\n    abstract sortInstanceNodePosition(a: Instance, b: Instance): number\n\n    /**\n     * Measure the viewport-relative bounding box of the Instance.\n     */\n    abstract measureInstanceViewportBox(\n        instance: Instance,\n        props: MotionProps & Partial<MotionConfigContext>\n    ): Box\n\n    /**\n     * When a value has been removed from all animation props we need to\n     * pick a target to animate back to. For instance, for HTMLElements\n     * we can look in the style prop.\n     */\n    abstract getBaseTargetFromProps(\n        props: MotionProps,\n        key: string\n    ): AnyResolvedKeyframe | undefined | MotionValue\n\n    /**\n     * When we first animate to a value we need to animate it *from* a value.\n     * Often this have been specified via the initial prop but it might be\n     * that the value needs to be read from the Instance.\n     */\n    abstract readValueFromInstance(\n        instance: Instance,\n        key: string,\n        options: Options\n    ): AnyResolvedKeyframe | null | undefined\n\n    /**\n     * When a value has been removed from the VisualElement we use this to remove\n     * it from the inherting class' unique render state.\n     */\n    abstract removeValueFromRenderState(\n        key: string,\n        renderState: RenderState\n    ): void\n\n    /**\n     * Run before a React or VisualElement render, builds the latest motion\n     * values into an Instance-specific format. For example, HTMLVisualElement\n     * will use this step to build `style` and `var` values.\n     */\n    abstract build(\n        renderState: RenderState,\n        latestValues: ResolvedValues,\n        props: MotionProps\n    ): void\n\n    /**\n     * Apply the built values to the Instance. For example, HTMLElements will have\n     * styles applied via `setProperty` and the style attribute, whereas SVGElements\n     * will have values applied to attributes.\n     */\n    abstract renderInstance(\n        instance: Instance,\n        renderState: RenderState,\n        styleProp?: MotionStyle,\n        projection?: IProjectionNode\n    ): void\n\n    /**\n     * This method is called when a transform property is bound to a motion value.\n     * It's currently used to measure SVG elements when a new transform property is bound.\n     */\n    onBindTransform?(): void\n\n    /**\n     * If the component child is provided as a motion value, handle subscriptions\n     * with the renderer-specific VisualElement.\n     */\n    handleChildMotionValue?(): void\n\n    /**\n     * This method takes React props and returns found MotionValues. For example, HTML\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n     *\n     * This isn't an abstract method as it needs calling in the constructor, but it is\n     * intended to be one.\n     */\n    scrapeMotionValuesFromProps(\n        _props: MotionProps,\n        _prevProps: MotionProps,\n        _visualElement: VisualElement\n    ): {\n        [key: string]: MotionValue | AnyResolvedKeyframe\n    } {\n        return {}\n    }\n\n    /**\n     * A reference to the current underlying Instance, e.g. a HTMLElement\n     * or Three.Mesh etc.\n     */\n    current: Instance | null = null\n\n    /**\n     * A reference to the parent VisualElement (if exists).\n     */\n    parent: VisualElement | undefined\n\n    /**\n     * A set containing references to this VisualElement's children.\n     */\n    children = new Set<VisualElement>()\n\n    /**\n     * A set containing the latest children of this VisualElement. This is flushed\n     * at the start of every commit. We use it to calculate the stagger delay\n     * for newly-added children.\n     */\n    enteringChildren?: Set<VisualElement>\n\n    /**\n     * The depth of this VisualElement within the overall VisualElement tree.\n     */\n    depth: number\n\n    /**\n     * The current render state of this VisualElement. Defined by inherting VisualElements.\n     */\n    renderState: RenderState\n\n    /**\n     * An object containing the latest static values for each of this VisualElement's\n     * MotionValues.\n     */\n    latestValues: ResolvedValues\n\n    /**\n     * Determine what role this visual element should take in the variant tree.\n     */\n    isVariantNode: boolean = false\n    isControllingVariants: boolean = false\n\n    /**\n     * If this component is part of the variant tree, it should track\n     * any children that are also part of the tree. This is essentially\n     * a shadow tree to simplify logic around how to stagger over children.\n     */\n    variantChildren?: Set<VisualElement>\n\n    /**\n     * Decides whether this VisualElement should animate in reduced motion\n     * mode.\n     *\n     * TODO: This is currently set on every individual VisualElement but feels\n     * like it could be set globally.\n     */\n    shouldReduceMotion: boolean | null = null\n\n    /**\n     * Normally, if a component is controlled by a parent's variants, it can\n     * rely on that ancestor to trigger animations further down the tree.\n     * However, if a component is created after its parent is mounted, the parent\n     * won't trigger that mount animation so the child needs to.\n     *\n     * TODO: This might be better replaced with a method isParentMounted\n     */\n    manuallyAnimateOnMount: boolean\n\n    /**\n     * This can be set by AnimatePresence to force components that mount\n     * at the same time as it to mount as if they have initial={false} set.\n     */\n    blockInitialAnimation: boolean\n\n    /**\n     * A reference to this VisualElement's projection node, used in layout animations.\n     */\n    projection?: IProjectionNode\n\n    /**\n     * A map of all motion values attached to this visual element. Motion\n     * values are source of truth for any given animated value. A motion\n     * value might be provided externally by the component via props.\n     */\n    values = new Map<string, MotionValue>()\n\n    /**\n     * The AnimationState, this is hydrated by the animation Feature.\n     */\n    animationState?: AnimationState\n\n    KeyframeResolver = KeyframeResolver\n\n    /**\n     * The options used to create this VisualElement. The Options type is defined\n     * by the inheriting VisualElement and is passed straight through to the render functions.\n     */\n    readonly options: Options\n\n    /**\n     * A reference to the latest props provided to the VisualElement's host React component.\n     */\n    props: MotionProps\n    prevProps?: MotionProps\n\n    presenceContext: PresenceContextProps | null\n    prevPresenceContext?: PresenceContextProps | null\n\n    /**\n     * Cleanup functions for active features (hover/tap/exit etc)\n     */\n    private features: {\n        [K in keyof FeatureDefinitions]?: Feature<Instance>\n    } = {}\n\n    /**\n     * A map of every subscription that binds the provided or generated\n     * motion values onChange listeners to this visual element.\n     */\n    private valueSubscriptions = new Map<string, VoidFunction>()\n\n    /**\n     * A reference to the ReducedMotionConfig passed to the VisualElement's host React component.\n     */\n    private reducedMotionConfig: ReducedMotionConfig | undefined\n\n    /**\n     * On mount, this will be hydrated with a callback to disconnect\n     * this visual element from its parent on unmount.\n     */\n    private removeFromVariantTree: undefined | VoidFunction\n\n    /**\n     * A reference to the previously-provided motion values as returned\n     * from scrapeMotionValuesFromProps. We use the keys in here to determine\n     * if any motion values need to be removed after props are updated.\n     */\n    private prevMotionValues: MotionStyle = {}\n\n    /**\n     * When values are removed from all animation props we need to search\n     * for a fallback value to animate to. These values are tracked in baseTarget.\n     */\n    private baseTarget: ResolvedValues\n\n    /**\n     * Create an object of the values we initially animated from (if initial prop present).\n     */\n    private initialValues: ResolvedValues\n\n    /**\n     * An object containing a SubscriptionManager for each active event.\n     */\n    private events: {\n        [key: string]: SubscriptionManager<any>\n    } = {}\n\n    /**\n     * An object containing an unsubscribe function for each prop event subscription.\n     * For example, every \"Update\" event can have multiple subscribers via\n     * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n     */\n    private propEventSubscriptions: {\n        [key: string]: VoidFunction\n    } = {}\n\n    constructor(\n        {\n            parent,\n            props,\n            presenceContext,\n            reducedMotionConfig,\n            blockInitialAnimation,\n            visualState,\n        }: VisualElementOptions<Instance, RenderState>,\n        options: Options = {} as any\n    ) {\n        const { latestValues, renderState } = visualState\n        this.latestValues = latestValues\n        this.baseTarget = { ...latestValues }\n        this.initialValues = props.initial ? { ...latestValues } : {}\n        this.renderState = renderState\n        this.parent = parent\n        this.props = props\n        this.presenceContext = presenceContext\n        this.depth = parent ? parent.depth + 1 : 0\n        this.reducedMotionConfig = reducedMotionConfig\n        this.options = options\n        this.blockInitialAnimation = Boolean(blockInitialAnimation)\n\n        this.isControllingVariants = checkIsControllingVariants(props)\n        this.isVariantNode = checkIsVariantNode(props)\n        if (this.isVariantNode) {\n            this.variantChildren = new Set()\n        }\n\n        this.manuallyAnimateOnMount = Boolean(parent && parent.current)\n\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't necessarily a breaking change,\n         * more a reflection of the test.\n         */\n        const { willChange, ...initialMotionValues } =\n            this.scrapeMotionValuesFromProps(props, {}, this)\n\n        for (const key in initialMotionValues) {\n            const value = initialMotionValues[key]\n\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key])\n            }\n        }\n    }\n\n    mount(instance: Instance) {\n        this.current = instance\n\n        visualElementStore.set(instance, this)\n\n        if (this.projection && !this.projection.instance) {\n            this.projection.mount(instance)\n        }\n\n        if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n            this.removeFromVariantTree = this.parent.addVariantChild(this)\n        }\n\n        this.values.forEach((value, key) => this.bindToMotionValue(key, value))\n\n        /**\n         * Determine reduced motion preference. Only initialize the matchMedia\n         * listener if we actually need the dynamic value (i.e., when config\n         * is neither \"never\" nor \"always\").\n         */\n        if (this.reducedMotionConfig === \"never\") {\n            this.shouldReduceMotion = false\n        } else if (this.reducedMotionConfig === \"always\") {\n            this.shouldReduceMotion = true\n        } else {\n            if (!hasReducedMotionListener.current) {\n                initPrefersReducedMotion()\n            }\n            this.shouldReduceMotion = prefersReducedMotion.current\n        }\n\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(\n                this.shouldReduceMotion !== true,\n                \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\",\n                \"reduced-motion-disabled\"\n            )\n        }\n\n        this.parent?.addChild(this)\n\n        this.update(this.props, this.presenceContext)\n    }\n\n    unmount() {\n        this.projection && this.projection.unmount()\n        cancelFrame(this.notifyUpdate)\n        cancelFrame(this.render)\n        this.valueSubscriptions.forEach((remove) => remove())\n        this.valueSubscriptions.clear()\n        this.removeFromVariantTree && this.removeFromVariantTree()\n        this.parent?.removeChild(this)\n\n        for (const key in this.events) {\n            this.events[key].clear()\n        }\n\n        for (const key in this.features) {\n            const feature = this.features[key as keyof typeof this.features]\n            if (feature) {\n                feature.unmount()\n                feature.isMounted = false\n            }\n        }\n        this.current = null\n    }\n\n    addChild(child: VisualElement) {\n        this.children.add(child)\n        this.enteringChildren ??= new Set()\n        this.enteringChildren.add(child)\n    }\n\n    removeChild(child: VisualElement) {\n        this.children.delete(child)\n        this.enteringChildren && this.enteringChildren.delete(child)\n    }\n\n    private bindToMotionValue(key: string, value: MotionValue) {\n        if (this.valueSubscriptions.has(key)) {\n            this.valueSubscriptions.get(key)!()\n        }\n\n        const valueIsTransform = transformProps.has(key)\n\n        if (valueIsTransform && this.onBindTransform) {\n            this.onBindTransform()\n        }\n\n        const removeOnChange = value.on(\n            \"change\",\n            (latestValue: AnyResolvedKeyframe) => {\n                this.latestValues[key] = latestValue\n\n                this.props.onUpdate && frame.preRender(this.notifyUpdate)\n\n                if (valueIsTransform && this.projection) {\n                    this.projection.isTransformDirty = true\n                }\n\n                this.scheduleRender()\n            }\n        )\n\n        let removeSyncCheck: VoidFunction | void\n        if (window.MotionCheckAppearSync) {\n            removeSyncCheck = window.MotionCheckAppearSync(this, key, value)\n        }\n\n        this.valueSubscriptions.set(key, () => {\n            removeOnChange()\n            if (removeSyncCheck) removeSyncCheck()\n            if (value.owner) value.stop()\n        })\n    }\n\n    sortNodePosition(other: VisualElement<Instance>) {\n        /**\n         * If these nodes aren't even of the same type we can't compare their depth.\n         */\n        if (\n            !this.current ||\n            !this.sortInstanceNodePosition ||\n            this.type !== other.type\n        ) {\n            return 0\n        }\n\n        return this.sortInstanceNodePosition(\n            this.current as Instance,\n            other.current as Instance\n        )\n    }\n\n    updateFeatures() {\n        let key: keyof typeof featureDefinitions = \"animation\"\n\n        for (key in featureDefinitions) {\n            const featureDefinition = featureDefinitions[key]\n\n            if (!featureDefinition) continue\n\n            const { isEnabled, Feature: FeatureConstructor } = featureDefinition\n\n            /**\n             * If this feature is enabled but not active, make a new instance.\n             */\n            if (\n                !this.features[key] &&\n                FeatureConstructor &&\n                isEnabled(this.props)\n            ) {\n                this.features[key] = new FeatureConstructor(this) as any\n            }\n\n            /**\n             * If we have a feature, mount or update it.\n             */\n            if (this.features[key]) {\n                const feature = this.features[key]!\n                if (feature.isMounted) {\n                    feature.update()\n                } else {\n                    feature.mount()\n                    feature.isMounted = true\n                }\n            }\n        }\n    }\n\n    notifyUpdate = () => this.notify(\"Update\", this.latestValues)\n\n    triggerBuild() {\n        this.build(this.renderState, this.latestValues, this.props)\n    }\n\n    render = () => {\n        if (!this.current) return\n        this.triggerBuild()\n        this.renderInstance(\n            this.current,\n            this.renderState,\n            this.props.style,\n            this.projection\n        )\n    }\n\n    private renderScheduledAt = 0.0\n    scheduleRender = () => {\n        const now = time.now()\n        if (this.renderScheduledAt < now) {\n            this.renderScheduledAt = now\n            frame.render(this.render, false, true)\n        }\n    }\n\n    /**\n     * Measure the current viewport box with or without transforms.\n     * Only measures axis-aligned boxes, rotate and skew must be manually\n     * removed with a re-render to work.\n     */\n    measureViewportBox() {\n        return this.current\n            ? this.measureInstanceViewportBox(this.current, this.props)\n            : createBox()\n    }\n\n    getStaticValue(key: string) {\n        return this.latestValues[key]\n    }\n\n    setStaticValue(key: string, value: AnyResolvedKeyframe) {\n        this.latestValues[key] = value\n    }\n\n    /**\n     * Update the provided props. Ensure any newly-added motion values are\n     * added to our map, old ones removed, and listeners updated.\n     */\n    update(props: MotionProps, presenceContext: PresenceContextProps | null) {\n        if (props.transformTemplate || this.props.transformTemplate) {\n            this.scheduleRender()\n        }\n\n        this.prevProps = this.props\n        this.props = props\n\n        this.prevPresenceContext = this.presenceContext\n        this.presenceContext = presenceContext\n\n        /**\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\n         */\n        for (let i = 0; i < propEventHandlers.length; i++) {\n            const key = propEventHandlers[i]\n            if (this.propEventSubscriptions[key]) {\n                this.propEventSubscriptions[key]()\n                delete this.propEventSubscriptions[key]\n            }\n\n            const listenerName = (\"on\" + key) as keyof typeof props\n            const listener = props[listenerName]\n            if (listener) {\n                this.propEventSubscriptions[key] = this.on(key as any, listener)\n            }\n        }\n\n        this.prevMotionValues = updateMotionValuesFromProps(\n            this,\n            this.scrapeMotionValuesFromProps(props, this.prevProps, this),\n            this.prevMotionValues\n        )\n\n        if (this.handleChildMotionValue) {\n            this.handleChildMotionValue()\n        }\n    }\n\n    getProps() {\n        return this.props\n    }\n\n    /**\n     * Returns the variant definition with a given name.\n     */\n    getVariant(name: string) {\n        return this.props.variants ? this.props.variants[name] : undefined\n    }\n\n    /**\n     * Returns the defined default transition on this component.\n     */\n    getDefaultTransition() {\n        return this.props.transition\n    }\n\n    getTransformPagePoint() {\n        return (this.props as any).transformPagePoint\n    }\n\n    getClosestVariantNode(): VisualElement | undefined {\n        return this.isVariantNode\n            ? this\n            : this.parent\n            ? this.parent.getClosestVariantNode()\n            : undefined\n    }\n\n    /**\n     * Add a child visual element to our set of children.\n     */\n    addVariantChild(child: VisualElement) {\n        const closestVariantNode = this.getClosestVariantNode()\n        if (closestVariantNode) {\n            closestVariantNode.variantChildren &&\n                closestVariantNode.variantChildren.add(child)\n            return () => closestVariantNode.variantChildren!.delete(child)\n        }\n    }\n\n    /**\n     * Add a motion value and bind it to this visual element.\n     */\n    addValue(key: string, value: MotionValue) {\n        // Remove existing value if it exists\n        const existingValue = this.values.get(key)\n\n        if (value !== existingValue) {\n            if (existingValue) this.removeValue(key)\n            this.bindToMotionValue(key, value)\n            this.values.set(key, value)\n            this.latestValues[key] = value.get()\n        }\n    }\n\n    /**\n     * Remove a motion value and unbind any active subscriptions.\n     */\n    removeValue(key: string) {\n        this.values.delete(key)\n        const unsubscribe = this.valueSubscriptions.get(key)\n        if (unsubscribe) {\n            unsubscribe()\n            this.valueSubscriptions.delete(key)\n        }\n        delete this.latestValues[key]\n        this.removeValueFromRenderState(key, this.renderState)\n    }\n\n    /**\n     * Check whether we have a motion value for this key\n     */\n    hasValue(key: string) {\n        return this.values.has(key)\n    }\n\n    /**\n     * Get a motion value for this key. If called with a default\n     * value, we'll create one if none exists.\n     */\n    getValue(key: string): MotionValue | undefined\n    getValue(key: string, defaultValue: AnyResolvedKeyframe | null): MotionValue\n    getValue(\n        key: string,\n        defaultValue?: AnyResolvedKeyframe | null\n    ): MotionValue | undefined {\n        if (this.props.values && this.props.values[key]) {\n            return this.props.values[key]\n        }\n\n        let value = this.values.get(key)\n\n        if (value === undefined && defaultValue !== undefined) {\n            value = motionValue(\n                defaultValue === null ? undefined : defaultValue,\n                { owner: this }\n            )\n            this.addValue(key, value)\n        }\n\n        return value\n    }\n\n    /**\n     * If we're trying to animate to a previously unencountered value,\n     * we need to check for it in our state and as a last resort read it\n     * directly from the instance (which might have performance implications).\n     */\n    readValue(key: string, target?: AnyResolvedKeyframe | null) {\n        let value =\n            this.latestValues[key] !== undefined || !this.current\n                ? this.latestValues[key]\n                : this.getBaseTargetFromProps(this.props, key) ??\n                  this.readValueFromInstance(this.current, key, this.options)\n\n        if (value !== undefined && value !== null) {\n            if (\n                typeof value === \"string\" &&\n                (isNumericalString(value) || isZeroValueString(value))\n            ) {\n                // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n                value = parseFloat(value)\n            } else if (!findValueType(value) && complex.test(target)) {\n                value = getAnimatableNone(key, target as string)\n            }\n\n            this.setBaseTarget(key, isMotionValue(value) ? value.get() : value)\n        }\n\n        return isMotionValue(value) ? value.get() : value\n    }\n\n    /**\n     * Set the base target to later animate back to. This is currently\n     * only hydrated on creation and when we first read a value.\n     */\n    setBaseTarget(key: string, value: AnyResolvedKeyframe) {\n        this.baseTarget[key] = value\n    }\n\n    /**\n     * Find the base target for a value thats been removed from all animation\n     * props.\n     */\n    getBaseTarget(key: string): ResolvedValues[string] | undefined | null {\n        const { initial } = this.props\n\n        let valueFromInitial: ResolvedValues[string] | undefined | null\n\n        if (typeof initial === \"string\" || typeof initial === \"object\") {\n            const variant = resolveVariantFromProps(\n                this.props,\n                initial as any,\n                this.presenceContext?.custom\n            )\n            if (variant) {\n                valueFromInitial = variant[\n                    key as keyof typeof variant\n                ] as string\n            }\n        }\n\n        /**\n         * If this value still exists in the current initial variant, read that.\n         */\n        if (initial && valueFromInitial !== undefined) {\n            return valueFromInitial\n        }\n\n        /**\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\n         * so we can read the value from an alternative source, try that.\n         */\n        const target = this.getBaseTargetFromProps(this.props, key)\n        if (target !== undefined && !isMotionValue(target)) return target\n\n        /**\n         * If the value was initially defined on initial, but it doesn't any more,\n         * return undefined. Otherwise return the value as initially read from the DOM.\n         */\n        return this.initialValues[key] !== undefined &&\n            valueFromInitial === undefined\n            ? undefined\n            : this.baseTarget[key]\n    }\n\n    on<EventName extends keyof VisualElementEventCallbacks>(\n        eventName: EventName,\n        callback: VisualElementEventCallbacks[EventName]\n    ) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager()\n        }\n\n        return this.events[eventName].add(callback)\n    }\n\n    notify<EventName extends keyof VisualElementEventCallbacks>(\n        eventName: EventName,\n        ...args: any\n    ) {\n        if (this.events[eventName]) {\n            this.events[eventName].notify(...args)\n        }\n    }\n\n    scheduleRenderMicrotask() {\n        microtask.render(this.render)\n    }\n}\n","import {\n    AnyResolvedKeyframe,\n    DOMKeyframesResolver,\n    isMotionValue,\n    MotionValue,\n} from \"motion-dom\"\nimport { MotionProps, MotionStyle } from \"../../motion/types\"\nimport { DOMVisualElementOptions } from \"../dom/types\"\nimport { HTMLRenderState } from \"../html/types\"\nimport { VisualElement } from \"../VisualElement\"\n\nexport abstract class DOMVisualElement<\n    Instance extends HTMLElement | SVGElement = HTMLElement,\n    State extends HTMLRenderState = HTMLRenderState,\n    Options extends DOMVisualElementOptions = DOMVisualElementOptions\n> extends VisualElement<Instance, State, Options> {\n    sortInstanceNodePosition(a: Instance, b: Instance): number {\n        /**\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\n         * to true if b preceeds a.\n         */\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1\n    }\n\n    getBaseTargetFromProps(\n        props: MotionProps,\n        key: string\n    ): AnyResolvedKeyframe | MotionValue<any> | undefined {\n        return props.style\n            ? (props.style[key as keyof MotionStyle] as string)\n            : undefined\n    }\n\n    removeValueFromRenderState(\n        key: string,\n        { vars, style }: HTMLRenderState\n    ): void {\n        delete vars[key]\n        delete style[key]\n    }\n\n    KeyframeResolver = DOMKeyframesResolver\n\n    childSubscription?: VoidFunction\n    handleChildMotionValue() {\n        if (this.childSubscription) {\n            this.childSubscription()\n            delete this.childSubscription\n        }\n\n        const { children } = this.props\n        if (isMotionValue(children)) {\n            this.childSubscription = children.on(\"change\", (latest) => {\n                if (this.current) {\n                    this.current.textContent = `${latest}`\n                }\n            })\n        }\n    }\n}\n","import {\n    getValueAsType,\n    numberValueTypes,\n    transformPropOrder,\n} from \"motion-dom\"\nimport { MotionProps } from \"../../../motion/types\"\nimport { ResolvedValues } from \"../../types\"\nimport { HTMLRenderState } from \"../types\"\n\nconst translateAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n    transformPerspective: \"perspective\",\n}\n\nconst numTransforms = transformPropOrder.length\n\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\nexport function buildTransform(\n    latestValues: ResolvedValues,\n    transform: HTMLRenderState[\"transform\"],\n    transformTemplate?: MotionProps[\"transformTemplate\"]\n) {\n    // The transform string we're going to build into.\n    let transformString = \"\"\n    let transformIsDefault = true\n\n    /**\n     * Loop over all possible transforms in order, adding the ones that\n     * are present to the transform string.\n     */\n    for (let i = 0; i < numTransforms; i++) {\n        const key = transformPropOrder[i] as keyof typeof translateAlias\n        const value = latestValues[key]\n\n        if (value === undefined) continue\n\n        let valueIsDefault = true\n        if (typeof value === \"number\") {\n            valueIsDefault = value === (key.startsWith(\"scale\") ? 1 : 0)\n        } else {\n            valueIsDefault = parseFloat(value) === 0\n        }\n\n        if (!valueIsDefault || transformTemplate) {\n            const valueAsType = getValueAsType(value, numberValueTypes[key])\n\n            if (!valueIsDefault) {\n                transformIsDefault = false\n                const transformName = translateAlias[key] || key\n                transformString += `${transformName}(${valueAsType}) `\n            }\n\n            if (transformTemplate) {\n                transform[key] = valueAsType\n            }\n        }\n    }\n\n    transformString = transformString.trim()\n\n    // If we have a custom `transform` template, pass our transform values and\n    // generated transformString to that before returning\n    if (transformTemplate) {\n        transformString = transformTemplate(\n            transform,\n            transformIsDefault ? \"\" : transformString\n        )\n    } else if (transformIsDefault) {\n        transformString = \"none\"\n    }\n\n    return transformString\n}\n","import {\n    getValueAsType,\n    isCSSVariableName,\n    numberValueTypes,\n    transformProps,\n} from \"motion-dom\"\nimport { MotionProps } from \"../../../motion/types\"\nimport { ResolvedValues } from \"../../types\"\nimport { HTMLRenderState } from \"../types\"\nimport { buildTransform } from \"./build-transform\"\n\nexport function buildHTMLStyles(\n    state: HTMLRenderState,\n    latestValues: ResolvedValues,\n    transformTemplate?: MotionProps[\"transformTemplate\"]\n) {\n    const { style, vars, transformOrigin } = state\n\n    // Track whether we encounter any transform or transformOrigin values.\n    let hasTransform = false\n    let hasTransformOrigin = false\n\n    /**\n     * Loop over all our latest animated values and decide whether to handle them\n     * as a style or CSS variable.\n     *\n     * Transforms and transform origins are kept separately for further processing.\n     */\n    for (const key in latestValues) {\n        const value = latestValues[key]\n\n        if (transformProps.has(key)) {\n            // If this is a transform, flag to enable further transform processing\n            hasTransform = true\n            continue\n        } else if (isCSSVariableName(key)) {\n            vars[key] = value\n            continue\n        } else {\n            // Convert the value to its default value type, ie 0 -> \"0px\"\n            const valueAsType = getValueAsType(value, numberValueTypes[key])\n\n            if (key.startsWith(\"origin\")) {\n                // If this is a transform origin, flag and enable further transform-origin processing\n                hasTransformOrigin = true\n                transformOrigin[key as keyof typeof transformOrigin] =\n                    valueAsType\n            } else {\n                style[key] = valueAsType\n            }\n        }\n    }\n\n    if (!latestValues.transform) {\n        if (hasTransform || transformTemplate) {\n            style.transform = buildTransform(\n                latestValues,\n                state.transform,\n                transformTemplate\n            )\n        } else if (style.transform) {\n            /**\n             * If we have previously created a transform but currently don't have any,\n             * reset transform style to none.\n             */\n            style.transform = \"none\"\n        }\n    }\n\n    /**\n     * Build a transformOrigin style. Uses the same defaults as the browser for\n     * undefined origins.\n     */\n    if (hasTransformOrigin) {\n        const {\n            originX = \"50%\",\n            originY = \"50%\",\n            originZ = 0,\n        } = transformOrigin\n        style.transformOrigin = `${originX} ${originY} ${originZ}`\n    }\n}\n","import { MotionStyle } from \"../../..\"\nimport { IProjectionNode } from \"../../../projection/node/types\"\nimport { HTMLRenderState } from \"../types\"\n\nexport function renderHTML(\n    element: HTMLElement,\n    { style, vars }: HTMLRenderState,\n    styleProp?: MotionStyle,\n    projection?: IProjectionNode\n) {\n    const elementStyle = element.style\n\n    let key: string\n    for (key in style) {\n        // CSSStyleDeclaration has [index: number]: string; in the types, so we use that as key type.\n        elementStyle[key as unknown as number] = style[key] as string\n    }\n\n    // Write projection styles directly to element style\n    projection?.applyProjectionStyles(elementStyle, styleProp)\n\n    for (key in vars) {\n        // Loop over any CSS variables and assign those.\n        // They can only be assigned using `setProperty`.\n        elementStyle.setProperty(key, vars[key] as string)\n    }\n}\n","import { px } from \"motion-dom\"\nimport { Axis } from \"motion-utils\"\nimport { ScaleCorrectorDefinition } from \"./types\"\n\nexport function pixelsToPercent(pixels: number, axis: Axis): number {\n    if (axis.max === axis.min) return 0\n    return (pixels / (axis.max - axis.min)) * 100\n}\n\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */\nexport const correctBorderRadius: ScaleCorrectorDefinition = {\n    correct: (latest, node) => {\n        if (!node.target) return latest\n\n        /**\n         * If latest is a string, if it's a percentage we can return immediately as it's\n         * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\n         */\n        if (typeof latest === \"string\") {\n            if (px.test(latest)) {\n                latest = parseFloat(latest)\n            } else {\n                return latest\n            }\n        }\n\n        /**\n         * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n         * pixel value as a percentage of each axis\n         */\n        const x = pixelsToPercent(latest, node.target.x)\n        const y = pixelsToPercent(latest, node.target.y)\n\n        return `${x}% ${y}%`\n    },\n}\n","import { complex, mixNumber } from \"motion-dom\"\nimport { ScaleCorrectorDefinition } from \"./types\"\n\nexport const correctBoxShadow: ScaleCorrectorDefinition = {\n    correct: (latest: string, { treeScale, projectionDelta }) => {\n        const original = latest\n        const shadow = complex.parse(latest)\n\n        // TODO: Doesn't support multiple shadows\n        if (shadow.length > 5) return original\n\n        const template = complex.createTransformer(latest)\n        const offset = typeof shadow[0] !== \"number\" ? 1 : 0\n\n        // Calculate the overall context scale\n        const xScale = projectionDelta!.x.scale * treeScale!.x\n        const yScale = projectionDelta!.y.scale * treeScale!.y\n\n        // Scale x/y\n        ;(shadow[0 + offset] as number) /= xScale\n        ;(shadow[1 + offset] as number) /= yScale\n\n        /**\n         * Ideally we'd correct x and y scales individually, but because blur and\n         * spread apply to both we have to take a scale average and apply that instead.\n         * We could potentially improve the outcome of this by incorporating the ratio between\n         * the two scales.\n         */\n        const averageScale = mixNumber(xScale, yScale, 0.5)\n\n        // Blur\n        if (typeof shadow[2 + offset] === \"number\")\n            (shadow[2 + offset] as number) /= averageScale\n\n        // Spread\n        if (typeof shadow[3 + offset] === \"number\")\n            (shadow[3 + offset] as number) /= averageScale\n\n        return template(shadow)\n    },\n}\n","import { isCSSVariableName } from \"motion-dom\"\nimport { correctBorderRadius } from \"./scale-border-radius\"\nimport { correctBoxShadow } from \"./scale-box-shadow\"\nimport { ScaleCorrectorMap } from \"./types\"\n\nexport const scaleCorrectors: ScaleCorrectorMap = {\n    borderRadius: {\n        ...correctBorderRadius,\n        applyTo: [\n            \"borderTopLeftRadius\",\n            \"borderTopRightRadius\",\n            \"borderBottomLeftRadius\",\n            \"borderBottomRightRadius\",\n        ],\n    },\n    borderTopLeftRadius: correctBorderRadius,\n    borderTopRightRadius: correctBorderRadius,\n    borderBottomLeftRadius: correctBorderRadius,\n    borderBottomRightRadius: correctBorderRadius,\n    boxShadow: correctBoxShadow,\n}\n\nexport function addScaleCorrector(correctors: ScaleCorrectorMap) {\n    for (const key in correctors) {\n        scaleCorrectors[key] = correctors[key]\n        if (isCSSVariableName(key)) {\n            scaleCorrectors[key].isCSSVariable = true\n        }\n    }\n}\n","import { transformProps } from \"motion-dom\"\nimport { MotionProps } from \"../..\"\nimport { scaleCorrectors } from \"../../projection/styles/scale-correction\"\n\nexport function isForcedMotionValue(\n    key: string,\n    { layout, layoutId }: MotionProps\n) {\n    return (\n        transformProps.has(key) ||\n        key.startsWith(\"origin\") ||\n        ((layout || layoutId !== undefined) &&\n            (!!scaleCorrectors[key] || key === \"opacity\"))\n    )\n}\n","import { isMotionValue } from \"motion-dom\"\nimport { MotionProps, MotionStyle } from \"../../../motion/types\"\nimport { isForcedMotionValue } from \"../../../motion/utils/is-forced-motion-value\"\nimport type { VisualElement } from \"../../VisualElement\"\n\nexport function scrapeMotionValuesFromProps(\n    props: MotionProps,\n    prevProps: MotionProps,\n    visualElement?: VisualElement\n) {\n    const { style } = props\n    const newValues: { [key: string]: any } = {}\n\n    for (const key in style) {\n        if (\n            isMotionValue(style[key as keyof MotionStyle]) ||\n            (prevProps.style &&\n                isMotionValue(prevProps.style[key as keyof MotionStyle])) ||\n            isForcedMotionValue(key, props) ||\n            visualElement?.getValue(key)?.liveStyle !== undefined\n        ) {\n            newValues[key] = style[key as keyof MotionStyle]\n        }\n    }\n\n    return newValues\n}\n","import {\n    AnyResolvedKeyframe,\n    defaultTransformValue,\n    isCSSVariableName,\n    readTransformValue,\n    transformProps,\n} from \"motion-dom\"\nimport type { Box } from \"motion-utils\"\nimport { MotionConfigContext } from \"../../context/MotionConfigContext\"\nimport { MotionProps } from \"../../motion/types\"\nimport { measureViewportBox } from \"../../projection/utils/measure\"\nimport { DOMVisualElement } from \"../dom/DOMVisualElement\"\nimport { DOMVisualElementOptions } from \"../dom/types\"\nimport type { ResolvedValues } from \"../types\"\nimport { VisualElement } from \"../VisualElement\"\nimport { HTMLRenderState } from \"./types\"\nimport { buildHTMLStyles } from \"./utils/build-styles\"\nimport { renderHTML } from \"./utils/render\"\nimport { scrapeMotionValuesFromProps } from \"./utils/scrape-motion-values\"\n\nexport function getComputedStyle(element: HTMLElement) {\n    return window.getComputedStyle(element)\n}\n\nexport class HTMLVisualElement extends DOMVisualElement<\n    HTMLElement,\n    HTMLRenderState,\n    DOMVisualElementOptions\n> {\n    type = \"html\"\n\n    readValueFromInstance(\n        instance: HTMLElement,\n        key: string\n    ): AnyResolvedKeyframe | null | undefined {\n        if (transformProps.has(key)) {\n            return this.projection?.isProjecting\n                ? defaultTransformValue(key)\n                : readTransformValue(instance, key)\n        } else {\n            const computedStyle = getComputedStyle(instance)\n            const value =\n                (isCSSVariableName(key)\n                    ? computedStyle.getPropertyValue(key)\n                    : computedStyle[key as keyof typeof computedStyle]) || 0\n\n            return typeof value === \"string\" ? value.trim() : (value as number)\n        }\n    }\n\n    measureInstanceViewportBox(\n        instance: HTMLElement,\n        { transformPagePoint }: MotionProps & Partial<MotionConfigContext>\n    ): Box {\n        return measureViewportBox(instance, transformPagePoint)\n    }\n\n    build(\n        renderState: HTMLRenderState,\n        latestValues: ResolvedValues,\n        props: MotionProps\n    ) {\n        buildHTMLStyles(renderState, latestValues, props.transformTemplate)\n    }\n\n    scrapeMotionValuesFromProps(\n        props: MotionProps,\n        prevProps: MotionProps,\n        visualElement: VisualElement\n    ) {\n        return scrapeMotionValuesFromProps(props, prevProps, visualElement)\n    }\n\n    renderInstance = renderHTML\n}\n","import { createBox } from \"../../projection/geometry/models\"\nimport { ResolvedValues } from \"../types\"\nimport { VisualElement } from \"../VisualElement\"\n\ninterface ObjectRenderState {\n    output: ResolvedValues\n}\n\nfunction isObjectKey(key: string, object: Object): key is keyof Object {\n    return key in object\n}\n\nexport class ObjectVisualElement extends VisualElement<\n    Object,\n    ObjectRenderState\n> {\n    type = \"object\"\n\n    readValueFromInstance(instance: Object, key: string) {\n        if (isObjectKey(key, instance)) {\n            const value = instance[key]\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                return value\n            }\n        }\n\n        return undefined\n    }\n\n    getBaseTargetFromProps() {\n        return undefined\n    }\n\n    removeValueFromRenderState(\n        key: string,\n        renderState: ObjectRenderState\n    ): void {\n        delete renderState.output[key]\n    }\n\n    measureInstanceViewportBox() {\n        return createBox()\n    }\n\n    build(renderState: ObjectRenderState, latestValues: ResolvedValues) {\n        Object.assign(renderState.output, latestValues)\n    }\n\n    renderInstance(instance: Object, { output }: ObjectRenderState) {\n        Object.assign(instance, output)\n    }\n\n    sortInstanceNodePosition() {\n        return 0\n    }\n}\n","import { px } from \"motion-dom\"\nimport { ResolvedValues } from \"../../types\"\n\nconst dashKeys = {\n    offset: \"stroke-dashoffset\",\n    array: \"stroke-dasharray\",\n}\n\nconst camelKeys = {\n    offset: \"strokeDashoffset\",\n    array: \"strokeDasharray\",\n}\n\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\nexport function buildSVGPath(\n    attrs: ResolvedValues,\n    length: number,\n    spacing = 1,\n    offset = 0,\n    useDashCase: boolean = true\n): void {\n    // Normalise path length by setting SVG attribute pathLength to 1\n    attrs.pathLength = 1\n\n    // We use dash case when setting attributes directly to the DOM node and camel case\n    // when defining props on a React component.\n    const keys = useDashCase ? dashKeys : camelKeys\n\n    // Build the dash offset\n    attrs[keys.offset] = px.transform!(-offset)\n\n    // Build the dash array\n    const pathLength = px.transform!(length)\n    const pathSpacing = px.transform!(spacing)\n    attrs[keys.array] = `${pathLength} ${pathSpacing}`\n}\n","import { MotionProps } from \"../../../motion/types\"\nimport { buildHTMLStyles } from \"../../html/utils/build-styles\"\nimport { ResolvedValues } from \"../../types\"\nimport { SVGRenderState } from \"../types\"\nimport { buildSVGPath } from \"./path\"\n\n/**\n * CSS Motion Path properties that should remain as CSS styles on SVG elements.\n */\nconst cssMotionPathProperties = [\n    \"offsetDistance\",\n    \"offsetPath\",\n    \"offsetRotate\",\n    \"offsetAnchor\",\n]\n\n/**\n * Build SVG visual attributes, like cx and style.transform\n */\nexport function buildSVGAttrs(\n    state: SVGRenderState,\n    {\n        attrX,\n        attrY,\n        attrScale,\n        pathLength,\n        pathSpacing = 1,\n        pathOffset = 0,\n        // This is object creation, which we try to avoid per-frame.\n        ...latest\n    }: ResolvedValues,\n    isSVGTag: boolean,\n    transformTemplate?: MotionProps[\"transformTemplate\"],\n    styleProp?: MotionProps[\"style\"]\n) {\n    buildHTMLStyles(state, latest, transformTemplate)\n\n    /**\n     * For svg tags we just want to make sure viewBox is animatable and treat all the styles\n     * as normal HTML tags.\n     */\n    if (isSVGTag) {\n        if (state.style.viewBox) {\n            state.attrs.viewBox = state.style.viewBox\n        }\n        return\n    }\n\n    state.attrs = state.style\n    state.style = {}\n    const { attrs, style } = state\n\n    /**\n     * However, we apply transforms as CSS transforms.\n     * So if we detect a transform, transformOrigin we take it from attrs and copy it into style.\n     */\n    if (attrs.transform) {\n        style.transform = attrs.transform\n        delete attrs.transform\n    }\n    if (style.transform || attrs.transformOrigin) {\n        style.transformOrigin = attrs.transformOrigin ?? \"50% 50%\"\n        delete attrs.transformOrigin\n    }\n\n    if (style.transform) {\n        /**\n         * SVG's element transform-origin uses its own median as a reference.\n         * Therefore, transformBox becomes a fill-box\n         */\n        style.transformBox = (styleProp?.transformBox as string) ?? \"fill-box\"\n        delete attrs.transformBox\n    }\n\n    for (const key of cssMotionPathProperties) {\n        if (attrs[key] !== undefined) {\n            style[key] = attrs[key]\n            delete attrs[key]\n        }\n    }\n\n    // Render attrX/attrY/attrScale as attributes\n    if (attrX !== undefined) attrs.x = attrX\n    if (attrY !== undefined) attrs.y = attrY\n    if (attrScale !== undefined) attrs.scale = attrScale\n\n    // Build SVG path if one has been defined\n    if (pathLength !== undefined) {\n        buildSVGPath(\n            attrs,\n            pathLength as number,\n            pathSpacing as number,\n            pathOffset as number,\n            false\n        )\n    }\n}\n","/**\n * A set of attribute names that are always read/written as camel case.\n */\nexport const camelCaseAttributes = new Set([\n    \"baseFrequency\",\n    \"diffuseConstant\",\n    \"kernelMatrix\",\n    \"kernelUnitLength\",\n    \"keySplines\",\n    \"keyTimes\",\n    \"limitingConeAngle\",\n    \"markerHeight\",\n    \"markerWidth\",\n    \"numOctaves\",\n    \"targetX\",\n    \"targetY\",\n    \"surfaceScale\",\n    \"specularConstant\",\n    \"specularExponent\",\n    \"stdDeviation\",\n    \"tableValues\",\n    \"viewBox\",\n    \"gradientTransform\",\n    \"pathLength\",\n    \"startOffset\",\n    \"textLength\",\n    \"lengthAdjust\",\n])\n","export const isSVGTag = (tag: unknown) =>\n    typeof tag === \"string\" && tag.toLowerCase() === \"svg\"\n","import { MotionStyle } from \"../../../motion/types\"\nimport { IProjectionNode } from \"../../../projection/node/types\"\nimport { camelToDash } from \"../../dom/utils/camel-to-dash\"\nimport { renderHTML } from \"../../html/utils/render\"\nimport { SVGRenderState } from \"../types\"\nimport { camelCaseAttributes } from \"./camel-case-attrs\"\n\nexport function renderSVG(\n    element: SVGElement,\n    renderState: SVGRenderState,\n    _styleProp?: MotionStyle,\n    projection?: IProjectionNode\n) {\n    renderHTML(element as any, renderState, undefined, projection)\n\n    for (const key in renderState.attrs) {\n        element.setAttribute(\n            !camelCaseAttributes.has(key) ? camelToDash(key) : key,\n            renderState.attrs[key] as string\n        )\n    }\n}\n","import { isMotionValue, transformPropOrder } from \"motion-dom\"\nimport { MotionProps } from \"../../../motion/types\"\nimport { scrapeMotionValuesFromProps as scrapeHTMLMotionValuesFromProps } from \"../../html/utils/scrape-motion-values\"\nimport type { VisualElement } from \"../../VisualElement\"\n\nexport function scrapeMotionValuesFromProps(\n    props: MotionProps,\n    prevProps: MotionProps,\n    visualElement?: VisualElement\n) {\n    const newValues = scrapeHTMLMotionValuesFromProps(\n        props,\n        prevProps,\n        visualElement\n    )\n\n    for (const key in props) {\n        if (\n            isMotionValue(props[key as keyof typeof props]) ||\n            isMotionValue(prevProps[key as keyof typeof prevProps])\n        ) {\n            const targetKey =\n                transformPropOrder.indexOf(key) !== -1\n                    ? \"attr\" + key.charAt(0).toUpperCase() + key.substring(1)\n                    : key\n\n            newValues[targetKey] = props[key as keyof typeof props]\n        }\n    }\n\n    return newValues\n}\n","import {\n    AnyResolvedKeyframe,\n    getDefaultValueType,\n    MotionValue,\n    transformProps,\n} from \"motion-dom\"\nimport { MotionProps, MotionStyle } from \"../../motion/types\"\nimport { createBox } from \"../../projection/geometry/models\"\nimport { IProjectionNode } from \"../../projection/node/types\"\nimport { DOMVisualElement } from \"../dom/DOMVisualElement\"\nimport { DOMVisualElementOptions } from \"../dom/types\"\nimport { camelToDash } from \"../dom/utils/camel-to-dash\"\nimport { ResolvedValues } from \"../types\"\nimport { VisualElement } from \"../VisualElement\"\nimport { SVGRenderState } from \"./types\"\nimport { buildSVGAttrs } from \"./utils/build-attrs\"\nimport { camelCaseAttributes } from \"./utils/camel-case-attrs\"\nimport { isSVGTag } from \"./utils/is-svg-tag\"\nimport { renderSVG } from \"./utils/render\"\nimport { scrapeMotionValuesFromProps } from \"./utils/scrape-motion-values\"\n\nexport class SVGVisualElement extends DOMVisualElement<\n    SVGElement,\n    SVGRenderState,\n    DOMVisualElementOptions\n> {\n    type = \"svg\"\n\n    isSVGTag = false\n\n    getBaseTargetFromProps(\n        props: MotionProps,\n        key: string\n    ): AnyResolvedKeyframe | MotionValue<any> | undefined {\n        return props[key as keyof MotionProps]\n    }\n\n    readValueFromInstance(instance: SVGElement, key: string) {\n        if (transformProps.has(key)) {\n            const defaultType = getDefaultValueType(key)\n            return defaultType ? defaultType.default || 0 : 0\n        }\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key\n        return instance.getAttribute(key)\n    }\n\n    measureInstanceViewportBox = createBox\n\n    scrapeMotionValuesFromProps(\n        props: MotionProps,\n        prevProps: MotionProps,\n        visualElement: VisualElement\n    ) {\n        return scrapeMotionValuesFromProps(props, prevProps, visualElement)\n    }\n\n    build(\n        renderState: SVGRenderState,\n        latestValues: ResolvedValues,\n        props: MotionProps\n    ) {\n        buildSVGAttrs(\n            renderState,\n            latestValues,\n            this.isSVGTag,\n            props.transformTemplate,\n            props.style\n        )\n    }\n\n    renderInstance(\n        instance: SVGElement,\n        renderState: SVGRenderState,\n        styleProp?: MotionStyle | undefined,\n        projection?: IProjectionNode<unknown> | undefined\n    ): void {\n        renderSVG(instance, renderState, styleProp, projection)\n    }\n\n    mount(instance: SVGElement) {\n        this.isSVGTag = isSVGTag(instance.tagName)\n        super.mount(instance)\n    }\n}\n","import { isSVGElement, isSVGSVGElement } from \"motion-dom\"\nimport { HTMLVisualElement } from \"../../render/html/HTMLVisualElement\"\nimport { ObjectVisualElement } from \"../../render/object/ObjectVisualElement\"\nimport { visualElementStore } from \"../../render/store\"\nimport { SVGVisualElement } from \"../../render/svg/SVGVisualElement\"\n\nexport function createDOMVisualElement(element: HTMLElement | SVGElement) {\n    const options = {\n        presenceContext: null,\n        props: {},\n        visualState: {\n            renderState: {\n                transform: {},\n                transformOrigin: {},\n                style: {},\n                vars: {},\n                attrs: {},\n            },\n            latestValues: {},\n        },\n    }\n    const node =\n        isSVGElement(element) && !isSVGSVGElement(element)\n            ? new SVGVisualElement(options)\n            : new HTMLVisualElement(options)\n\n    node.mount(element as any)\n\n    visualElementStore.set(element, node)\n}\n\nexport function createObjectVisualElement(subject: Object) {\n    const options = {\n        presenceContext: null,\n        props: {},\n        visualState: {\n            renderState: {\n                output: {},\n            },\n            latestValues: {},\n        },\n    }\n    const node = new ObjectVisualElement(options)\n\n    node.mount(subject)\n\n    visualElementStore.set(subject, node)\n}\n","import {\n    AnimationPlaybackControlsWithThen,\n    AnyResolvedKeyframe,\n    motionValue as createMotionValue,\n    isMotionValue,\n    MotionValue,\n    UnresolvedValueKeyframe,\n    ValueAnimationTransition,\n} from \"motion-dom\"\nimport { animateMotionValue } from \"../interfaces/motion-value\"\n\nexport function animateSingleValue<V extends AnyResolvedKeyframe>(\n    value: MotionValue<V> | V,\n    keyframes: V | UnresolvedValueKeyframe<V>[],\n    options?: ValueAnimationTransition\n): AnimationPlaybackControlsWithThen {\n    const motionValue = isMotionValue(value) ? value : createMotionValue(value)\n\n    motionValue.start(animateMotionValue(\"\", motionValue, keyframes, options))\n\n    return motionValue.animation!\n}\n","import {\n    AnimationPlaybackControlsWithThen,\n    AnimationScope,\n    AnyResolvedKeyframe,\n    DOMKeyframesDefinition,\n    AnimationOptions as DynamicAnimationOptions,\n    ElementOrSelector,\n    MotionValue,\n    TargetAndTransition,\n    UnresolvedValueKeyframe,\n    ValueAnimationTransition,\n    isMotionValue,\n} from \"motion-dom\"\nimport { invariant } from \"motion-utils\"\nimport { visualElementStore } from \"../../render/store\"\nimport { animateTarget } from \"../interfaces/visual-element-target\"\nimport { ObjectTarget } from \"../sequence/types\"\nimport {\n    createDOMVisualElement,\n    createObjectVisualElement,\n} from \"../utils/create-visual-element\"\nimport { isDOMKeyframes } from \"../utils/is-dom-keyframes\"\nimport { resolveSubjects } from \"./resolve-subjects\"\nimport { animateSingleValue } from \"./single-value\"\n\nexport type AnimationSubject = Element | MotionValue<any> | any\n\nfunction isSingleValue(\n    subject: unknown,\n    keyframes: unknown\n): subject is MotionValue | AnyResolvedKeyframe {\n    return (\n        isMotionValue(subject) ||\n        typeof subject === \"number\" ||\n        (typeof subject === \"string\" && !isDOMKeyframes(keyframes))\n    )\n}\n\n/**\n * Animate a string\n */\nexport function animateSubject(\n    value: string | MotionValue<string>,\n    keyframes: string | UnresolvedValueKeyframe<string>[],\n    options?: ValueAnimationTransition<string>\n): AnimationPlaybackControlsWithThen[]\n/**\n * Animate a number\n */\nexport function animateSubject(\n    value: number | MotionValue<number>,\n    keyframes: number | UnresolvedValueKeyframe<number>[],\n    options?: ValueAnimationTransition<number>\n): AnimationPlaybackControlsWithThen[]\n/**\n * Animate a Element\n */\nexport function animateSubject(\n    element: ElementOrSelector,\n    keyframes: DOMKeyframesDefinition,\n    options?: DynamicAnimationOptions,\n    scope?: AnimationScope\n): AnimationPlaybackControlsWithThen[]\n/**\n * Animate a object\n */\nexport function animateSubject<O extends Object>(\n    object: O | O[],\n    keyframes: ObjectTarget<O>,\n    options?: DynamicAnimationOptions\n): AnimationPlaybackControlsWithThen[]\n/**\n * Implementation\n */\nexport function animateSubject<O extends Object>(\n    subject:\n        | MotionValue<number>\n        | MotionValue<string>\n        | number\n        | string\n        | ElementOrSelector\n        | O\n        | O[],\n    keyframes:\n        | number\n        | string\n        | UnresolvedValueKeyframe<number>[]\n        | UnresolvedValueKeyframe<string>[]\n        | DOMKeyframesDefinition\n        | ObjectTarget<O>,\n    options?:\n        | ValueAnimationTransition<number>\n        | ValueAnimationTransition<string>\n        | DynamicAnimationOptions,\n    scope?: AnimationScope\n): AnimationPlaybackControlsWithThen[] {\n    const animations: AnimationPlaybackControlsWithThen[] = []\n\n    if (isSingleValue(subject, keyframes)) {\n        animations.push(\n            animateSingleValue(\n                subject,\n                isDOMKeyframes(keyframes)\n                    ? (keyframes as any).default || keyframes\n                    : keyframes,\n                options ? (options as any).default || options : options\n            )\n        )\n    } else {\n        const subjects = resolveSubjects(\n            subject,\n            keyframes as DOMKeyframesDefinition,\n            scope\n        )\n\n        const numSubjects = subjects.length\n\n        invariant(\n            Boolean(numSubjects),\n            \"No valid elements provided.\",\n            \"no-valid-elements\"\n        )\n\n        for (let i = 0; i < numSubjects; i++) {\n            const thisSubject = subjects[i]\n\n            invariant(\n                thisSubject !== null,\n                \"You're trying to perform an animation on null. Ensure that selectors are correctly finding elements and refs are correctly hydrated.\",\n                \"animate-null\"\n            )\n\n            const createVisualElement =\n                thisSubject instanceof Element\n                    ? createDOMVisualElement\n                    : createObjectVisualElement\n\n            if (!visualElementStore.has(thisSubject)) {\n                createVisualElement(thisSubject as any)\n            }\n\n            const visualElement = visualElementStore.get(thisSubject)!\n            const transition = { ...options }\n\n            /**\n             * Resolve stagger function if provided.\n             */\n            if (\n                \"delay\" in transition &&\n                typeof transition.delay === \"function\"\n            ) {\n                transition.delay = transition.delay(i, numSubjects)\n            }\n\n            animations.push(\n                ...animateTarget(\n                    visualElement,\n                    { ...(keyframes as {}), transition } as TargetAndTransition,\n                    {}\n                )\n            )\n        }\n    }\n\n    return animations\n}\n","import {\n    AnimationPlaybackControlsWithThen,\n    AnimationScope,\n    spring,\n} from \"motion-dom\"\nimport { createAnimationsFromSequence } from \"../sequence/create\"\nimport { AnimationSequence, SequenceOptions } from \"../sequence/types\"\nimport { animateSubject } from \"./subject\"\n\nexport function animateSequence(\n    sequence: AnimationSequence,\n    options?: SequenceOptions,\n    scope?: AnimationScope\n) {\n    const animations: AnimationPlaybackControlsWithThen[] = []\n\n    const animationDefinitions = createAnimationsFromSequence(\n        sequence,\n        options,\n        scope,\n        { spring }\n    )\n\n    animationDefinitions.forEach(({ keyframes, transition }, subject) => {\n        animations.push(...animateSubject(subject, keyframes, transition))\n    })\n\n    return animations\n}\n","import type {\n    AnimationPlaybackControlsWithThen,\n    AnimationScope,\n    DOMKeyframesDefinition,\n    AnimationOptions as DynamicAnimationOptions,\n    ElementOrSelector,\n    MotionValue,\n    UnresolvedValueKeyframe,\n    ValueAnimationTransition,\n} from \"motion-dom\"\nimport { GroupAnimationWithThen } from \"motion-dom\"\nimport { removeItem } from \"motion-utils\"\nimport {\n    AnimationSequence,\n    ObjectTarget,\n    SequenceOptions,\n} from \"../sequence/types\"\nimport { animateSequence } from \"./sequence\"\nimport { animateSubject } from \"./subject\"\n\nfunction isSequence(value: unknown): value is AnimationSequence {\n    return Array.isArray(value) && value.some(Array.isArray)\n}\n\n/**\n * Creates an animation function that is optionally scoped\n * to a specific element.\n */\nexport function createScopedAnimate(scope?: AnimationScope) {\n    /**\n     * Animate a sequence\n     */\n    function scopedAnimate(\n        sequence: AnimationSequence,\n        options?: SequenceOptions\n    ): AnimationPlaybackControlsWithThen\n    /**\n     * Animate a string\n     */\n    function scopedAnimate(\n        value: string | MotionValue<string>,\n        keyframes: string | UnresolvedValueKeyframe<string>[],\n        options?: ValueAnimationTransition<string>\n    ): AnimationPlaybackControlsWithThen\n    /**\n     * Animate a number\n     */\n    function scopedAnimate(\n        value: number | MotionValue<number>,\n        keyframes: number | UnresolvedValueKeyframe<number>[],\n        options?: ValueAnimationTransition<number>\n    ): AnimationPlaybackControlsWithThen\n    /**\n     * Animate a generic motion value\n     */\n    function scopedAnimate<V extends string | number>(\n        value: V | MotionValue<V>,\n        keyframes: V | UnresolvedValueKeyframe<V>[],\n        options?: ValueAnimationTransition<V>\n    ): AnimationPlaybackControlsWithThen\n    /**\n     * Animate an Element\n     */\n    function scopedAnimate(\n        element: ElementOrSelector,\n        keyframes: DOMKeyframesDefinition,\n        options?: DynamicAnimationOptions\n    ): AnimationPlaybackControlsWithThen\n    /**\n     * Animate an object\n     */\n    function scopedAnimate<O extends {}>(\n        object: O | O[],\n        keyframes: ObjectTarget<O>,\n        options?: DynamicAnimationOptions\n    ): AnimationPlaybackControlsWithThen\n    /**\n     * Implementation\n     */\n    function scopedAnimate<O extends {}>(\n        subjectOrSequence:\n            | AnimationSequence\n            | MotionValue<number>\n            | MotionValue<string>\n            | number\n            | string\n            | ElementOrSelector\n            | O\n            | O[],\n        optionsOrKeyframes?:\n            | SequenceOptions\n            | number\n            | string\n            | UnresolvedValueKeyframe<number>[]\n            | UnresolvedValueKeyframe<string>[]\n            | DOMKeyframesDefinition\n            | ObjectTarget<O>,\n        options?:\n            | ValueAnimationTransition<number>\n            | ValueAnimationTransition<string>\n            | DynamicAnimationOptions\n    ): AnimationPlaybackControlsWithThen {\n        let animations: AnimationPlaybackControlsWithThen[] = []\n        let animationOnComplete: VoidFunction | undefined\n\n        if (isSequence(subjectOrSequence)) {\n            animations = animateSequence(\n                subjectOrSequence,\n                optionsOrKeyframes as SequenceOptions,\n                scope\n            )\n        } else {\n            // Extract top-level onComplete so it doesn't get applied per-value\n            const { onComplete, ...rest } = options || {}\n            if (typeof onComplete === \"function\") {\n                animationOnComplete = onComplete as VoidFunction\n            }\n            animations = animateSubject(\n                subjectOrSequence as ElementOrSelector,\n                optionsOrKeyframes as DOMKeyframesDefinition,\n                rest as DynamicAnimationOptions,\n                scope\n            )\n        }\n\n        const animation = new GroupAnimationWithThen(animations)\n\n        if (animationOnComplete) {\n            animation.finished.then(animationOnComplete)\n        }\n\n        if (scope) {\n            scope.animations.push(animation)\n            animation.finished.then(() => {\n                removeItem(scope.animations, animation)\n            })\n        }\n\n        return animation\n    }\n\n    return scopedAnimate\n}\n\nexport const animate = createScopedAnimate()\n","import {\n    animationMapKey,\n    AnimationPlaybackControls,\n    AnimationScope,\n    applyPxDefaults,\n    DOMKeyframesDefinition,\n    AnimationOptions as DynamicAnimationOptions,\n    ElementOrSelector,\n    fillWildcards,\n    getAnimationMap,\n    getComputedStyle,\n    getValueTransition,\n    NativeAnimation,\n    NativeAnimationOptions,\n    resolveElements,\n    UnresolvedValueKeyframe,\n    ValueKeyframe,\n} from \"motion-dom\"\nimport { invariant, secondsToMilliseconds } from \"motion-utils\"\n\ninterface AnimationDefinition {\n    map: Map<string, NativeAnimation<any>>\n    key: string\n    unresolvedKeyframes: UnresolvedValueKeyframe[]\n    options: Omit<NativeAnimationOptions, \"keyframes\"> & {\n        keyframes?: ValueKeyframe[]\n    }\n}\n\nexport function animateElements(\n    elementOrSelector: ElementOrSelector,\n    keyframes: DOMKeyframesDefinition,\n    options?: DynamicAnimationOptions,\n    scope?: AnimationScope\n) {\n    const elements = resolveElements(elementOrSelector, scope) as Array<\n        HTMLElement | SVGElement\n    >\n    const numElements = elements.length\n\n    invariant(\n        Boolean(numElements),\n        \"No valid elements provided.\",\n        \"no-valid-elements\"\n    )\n\n    /**\n     * WAAPI doesn't support interrupting animations.\n     *\n     * Therefore, starting animations requires a three-step process:\n     * 1. Stop existing animations (write styles to DOM)\n     * 2. Resolve keyframes (read styles from DOM)\n     * 3. Create new animations (write styles to DOM)\n     *\n     * The hybrid `animate()` function uses AsyncAnimation to resolve\n     * keyframes before creating new animations, which removes style\n     * thrashing. Here, we have much stricter filesize constraints.\n     * Therefore we do this in a synchronous way that ensures that\n     * at least within `animate()` calls there is no style thrashing.\n     *\n     * In the motion-native-animate-mini-interrupt benchmark this\n     * was 80% faster than a single loop.\n     */\n    const animationDefinitions: AnimationDefinition[] = []\n\n    /**\n     * Step 1: Build options and stop existing animations (write)\n     */\n    for (let i = 0; i < numElements; i++) {\n        const element = elements[i]\n        const elementTransition: DynamicAnimationOptions = { ...options }\n\n        /**\n         * Resolve stagger function if provided.\n         */\n        if (typeof elementTransition.delay === \"function\") {\n            elementTransition.delay = elementTransition.delay(i, numElements)\n        }\n\n        for (const valueName in keyframes) {\n            let valueKeyframes = keyframes[valueName as keyof typeof keyframes]!\n\n            if (!Array.isArray(valueKeyframes)) {\n                valueKeyframes = [valueKeyframes]\n            }\n\n            const valueOptions = {\n                ...getValueTransition(elementTransition as any, valueName),\n            }\n\n            valueOptions.duration &&= secondsToMilliseconds(\n                valueOptions.duration\n            )\n\n            valueOptions.delay &&= secondsToMilliseconds(valueOptions.delay)\n\n            /**\n             * If there's an existing animation playing on this element then stop it\n             * before creating a new one.\n             */\n            const map = getAnimationMap(element)\n            const key = animationMapKey(\n                valueName,\n                valueOptions.pseudoElement || \"\"\n            )\n            const currentAnimation = map.get(key)\n            currentAnimation && currentAnimation.stop()\n\n            animationDefinitions.push({\n                map,\n                key,\n                unresolvedKeyframes: valueKeyframes,\n                options: {\n                    ...valueOptions,\n                    element,\n                    name: valueName,\n                    allowFlatten:\n                        !elementTransition.type && !elementTransition.ease,\n                },\n            })\n        }\n    }\n\n    /**\n     * Step 2: Resolve keyframes (read)\n     */\n    for (let i = 0; i < animationDefinitions.length; i++) {\n        const { unresolvedKeyframes, options: animationOptions } =\n            animationDefinitions[i]\n\n        const { element, name, pseudoElement } = animationOptions\n        if (!pseudoElement && unresolvedKeyframes[0] === null) {\n            unresolvedKeyframes[0] = getComputedStyle(element, name)\n        }\n\n        fillWildcards(unresolvedKeyframes)\n        applyPxDefaults(unresolvedKeyframes, name)\n\n        /**\n         * If we only have one keyframe, explicitly read the initial keyframe\n         * from the computed style. This is to ensure consistency with WAAPI behaviour\n         * for restarting animations, for instance .play() after finish, when it\n         * has one vs two keyframes.\n         */\n        if (!pseudoElement && unresolvedKeyframes.length < 2) {\n            unresolvedKeyframes.unshift(getComputedStyle(element, name))\n        }\n\n        animationOptions.keyframes = unresolvedKeyframes as ValueKeyframe[]\n    }\n\n    /**\n     * Step 3: Create new animations (write)\n     */\n    const animations: AnimationPlaybackControls[] = []\n    for (let i = 0; i < animationDefinitions.length; i++) {\n        const { map, key, options: animationOptions } = animationDefinitions[i]\n        const animation = new NativeAnimation(\n            animationOptions as NativeAnimationOptions\n        )\n\n        map.set(key, animation)\n        animation.finished.finally(() => map.delete(key))\n\n        animations.push(animation)\n    }\n\n    return animations\n}\n","import {\n    AnimationPlaybackControlsWithThen,\n    AnimationScope,\n    DOMKeyframesDefinition,\n    AnimationOptions as DynamicAnimationOptions,\n    ElementOrSelector,\n    GroupAnimationWithThen,\n} from \"motion-dom\"\nimport { animateElements } from \"./animate-elements\"\n\nexport const createScopedWaapiAnimate = (scope?: AnimationScope) => {\n    function scopedAnimate(\n        elementOrSelector: ElementOrSelector,\n        keyframes: DOMKeyframesDefinition,\n        options?: DynamicAnimationOptions\n    ): AnimationPlaybackControlsWithThen {\n        return new GroupAnimationWithThen(\n            animateElements(\n                elementOrSelector,\n                keyframes as DOMKeyframesDefinition,\n                options,\n                scope\n            )\n        )\n    }\n\n    return scopedAnimate\n}\n\nexport const animateMini = /*@__PURE__*/ createScopedWaapiAnimate()\n","import { progress, velocityPerSecond } from \"motion-utils\"\nimport { AxisScrollInfo, ScrollInfo } from \"./types\"\n\n/**\n * A time in milliseconds, beyond which we consider the scroll velocity to be 0.\n */\nconst maxElapsed = 50\n\nconst createAxisInfo = (): AxisScrollInfo => ({\n    current: 0,\n    offset: [],\n    progress: 0,\n    scrollLength: 0,\n    targetOffset: 0,\n    targetLength: 0,\n    containerLength: 0,\n    velocity: 0,\n})\n\nexport const createScrollInfo = (): ScrollInfo => ({\n    time: 0,\n    x: createAxisInfo(),\n    y: createAxisInfo(),\n})\n\nconst keys = {\n    x: {\n        length: \"Width\",\n        position: \"Left\",\n    },\n    y: {\n        length: \"Height\",\n        position: \"Top\",\n    },\n} as const\n\nfunction updateAxisInfo(\n    element: Element,\n    axisName: \"x\" | \"y\",\n    info: ScrollInfo,\n    time: number\n) {\n    const axis = info[axisName]\n    const { length, position } = keys[axisName]\n\n    const prev = axis.current\n    const prevTime = info.time\n\n    axis.current = element[`scroll${position}`]\n    axis.scrollLength = element[`scroll${length}`] - element[`client${length}`]\n\n    axis.offset.length = 0\n    axis.offset[0] = 0\n    axis.offset[1] = axis.scrollLength\n    axis.progress = progress(0, axis.scrollLength, axis.current)\n\n    const elapsed = time - prevTime\n    axis.velocity =\n        elapsed > maxElapsed\n            ? 0\n            : velocityPerSecond(axis.current - prev, elapsed)\n}\n\nexport function updateScrollInfo(\n    element: Element,\n    info: ScrollInfo,\n    time: number\n) {\n    updateAxisInfo(element, \"x\", info, time)\n    updateAxisInfo(element, \"y\", info, time)\n    info.time = time\n}\n","import { isHTMLElement } from \"motion-dom\"\n\nexport function calcInset(element: Element, container: Element) {\n    const inset = { x: 0, y: 0 }\n\n    let current: Element | null = element\n    while (current && current !== container) {\n        if (isHTMLElement(current)) {\n            inset.x += current.offsetLeft\n            inset.y += current.offsetTop\n            current = current.offsetParent\n        } else if (current.tagName === \"svg\") {\n            /**\n             * This isn't an ideal approach to measuring the offset of <svg /> tags.\n             * It would be preferable, given they behave like HTMLElements in most ways\n             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n             * can't use .getBBox() like most SVG elements as these provide the offset\n             * relative to the SVG itself, which for <svg /> is usually 0x0.\n             */\n            const svgBoundingBox = current.getBoundingClientRect()\n            current = current.parentElement!\n            const parentBoundingBox = current.getBoundingClientRect()\n            inset.x += svgBoundingBox.left - parentBoundingBox.left\n            inset.y += svgBoundingBox.top - parentBoundingBox.top\n        } else if (current instanceof SVGGraphicsElement) {\n            const { x, y } = current.getBBox()\n            inset.x += x\n            inset.y += y\n\n            let svg: SVGElement | null = null\n            let parent: SVGElement = current.parentNode as SVGElement\n            while (!svg) {\n                if (parent.tagName === \"svg\") {\n                    svg = parent\n                }\n                parent = current.parentNode as SVGElement\n            }\n            current = svg\n        } else {\n            break\n        }\n    }\n\n    return inset\n}\n","import { Edge, NamedEdges } from \"../types\"\n\nexport const namedEdges: Record<NamedEdges, number> = {\n    start: 0,\n    center: 0.5,\n    end: 1,\n}\n\nexport function resolveEdge(edge: Edge, length: number, inset = 0) {\n    let delta = 0\n\n    /**\n     * If we have this edge defined as a preset, replace the definition\n     * with the numerical value.\n     */\n    if (edge in namedEdges) {\n        edge = namedEdges[edge as NamedEdges]\n    }\n\n    /**\n     * Handle unit values\n     */\n    if (typeof edge === \"string\") {\n        const asNumber = parseFloat(edge)\n\n        if (edge.endsWith(\"px\")) {\n            delta = asNumber\n        } else if (edge.endsWith(\"%\")) {\n            edge = asNumber / 100\n        } else if (edge.endsWith(\"vw\")) {\n            delta = (asNumber / 100) * document.documentElement.clientWidth\n        } else if (edge.endsWith(\"vh\")) {\n            delta = (asNumber / 100) * document.documentElement.clientHeight\n        } else {\n            edge = asNumber\n        }\n    }\n\n    /**\n     * If the edge is defined as a number, handle as a progress value.\n     */\n    if (typeof edge === \"number\") {\n        delta = length * edge\n    }\n\n    return inset + delta\n}\n","import { Edge, EdgeString, Intersection, ProgressIntersection } from \"../types\"\nimport { namedEdges, resolveEdge } from \"./edge\"\n\nconst defaultOffset: ProgressIntersection = [0, 0]\n\nexport function resolveOffset(\n    offset: Edge | Intersection | ProgressIntersection,\n    containerLength: number,\n    targetLength: number,\n    targetInset: number\n) {\n    let offsetDefinition: ProgressIntersection | [EdgeString, EdgeString] =\n        Array.isArray(offset) ? offset : defaultOffset\n\n    let targetPoint = 0\n    let containerPoint = 0\n\n    if (typeof offset === \"number\") {\n        /**\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n         * and container etc.\n         */\n        offsetDefinition = [offset, offset]\n    } else if (typeof offset === \"string\") {\n        offset = offset.trim() as EdgeString\n\n        if (offset.includes(\" \")) {\n            offsetDefinition = offset.split(\" \") as [EdgeString, EdgeString]\n        } else {\n            /**\n             * If we're provided a definition like \"100px\" then we want to apply\n             * that only to the top of the target point, leaving the container at 0.\n             * Whereas a named offset like \"end\" should be applied to both.\n             */\n            offsetDefinition = [offset, namedEdges[offset as keyof typeof namedEdges] ? offset : `0`]\n        }\n    }\n\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset)\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength)\n\n    return targetPoint - containerPoint\n}\n","import { ProgressIntersection } from \"../types\"\n\nexport const ScrollOffset: Record<string, ProgressIntersection[]> = {\n  Enter: [\n    [0, 1],\n    [1, 1],\n  ],\n  Exit: [\n    [0, 0],\n    [1, 0],\n  ],\n  Any: [\n    [1, 0],\n    [0, 1],\n  ],\n  All: [\n    [0, 0],\n    [1, 1],\n  ],\n}\n","import { defaultOffset, interpolate } from \"motion-dom\"\nimport { clamp } from \"motion-utils\"\nimport { ScrollInfo, ScrollInfoOptions } from \"../types\"\nimport { calcInset } from \"./inset\"\nimport { resolveOffset } from \"./offset\"\nimport { ScrollOffset } from \"./presets\"\n\nconst point = { x: 0, y: 0 }\n\nfunction getTargetSize(target: Element) {\n    return \"getBBox\" in target && target.tagName !== \"svg\"\n        ? (target as SVGGraphicsElement).getBBox()\n        : { width: target.clientWidth, height: target.clientHeight }\n}\n\nexport function resolveOffsets(\n    container: Element,\n    info: ScrollInfo,\n    options: ScrollInfoOptions\n) {\n    const { offset: offsetDefinition = ScrollOffset.All } = options\n    const { target = container, axis = \"y\" } = options\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\"\n\n    const inset = target !== container ? calcInset(target, container) : point\n\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize =\n        target === container\n            ? { width: container.scrollWidth, height: container.scrollHeight }\n            : getTargetSize(target)\n\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    }\n\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0\n\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate\n\n    const numOffsets = offsetDefinition.length\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(\n            offsetDefinition[i],\n            containerSize[lengthLabel],\n            targetSize[lengthLabel],\n            inset[axis]\n        )\n\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets![i]) {\n            hasChanged = true\n        }\n\n        info[axis].offset[i] = offset\n    }\n\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(\n            info[axis].offset,\n            defaultOffset(offsetDefinition),\n            { clamp: false }\n        )\n\n        info[axis].interpolatorOffsets = [...info[axis].offset]\n    }\n\n    info[axis].progress = clamp(\n        0,\n        1,\n        info[axis].interpolate!(info[axis].current)\n    )\n}\n","import { warnOnce } from \"motion-utils\"\nimport { updateScrollInfo } from \"./info\"\nimport { resolveOffsets } from \"./offsets/index\"\nimport {\n    OnScrollHandler,\n    OnScrollInfo,\n    ScrollInfo,\n    ScrollInfoOptions,\n} from \"./types\"\n\nfunction measure(\n    container: Element,\n    target: Element = container,\n    info: ScrollInfo\n) {\n    /**\n     * Find inset of target within scrollable container\n     */\n    info.x.targetOffset = 0\n    info.y.targetOffset = 0\n    if (target !== container) {\n        let node = target as HTMLElement\n        while (node && node !== container) {\n            info.x.targetOffset += node.offsetLeft\n            info.y.targetOffset += node.offsetTop\n            node = node.offsetParent as HTMLElement\n        }\n    }\n\n    info.x.targetLength =\n        target === container ? target.scrollWidth : target.clientWidth\n    info.y.targetLength =\n        target === container ? target.scrollHeight : target.clientHeight\n    info.x.containerLength = container.clientWidth\n    info.y.containerLength = container.clientHeight\n\n    /**\n     * In development mode ensure scroll containers aren't position: static as this makes\n     * it difficult to measure their relative positions.\n     */\n    if (process.env.NODE_ENV !== \"production\") {\n        if (container && target && target !== container) {\n            warnOnce(\n                getComputedStyle(container).position !== \"static\",\n                \"Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.\"\n            )\n        }\n    }\n}\n\nexport function createOnScrollHandler(\n    element: Element,\n    onScroll: OnScrollInfo,\n    info: ScrollInfo,\n    options: ScrollInfoOptions = {}\n): OnScrollHandler {\n    return {\n        measure: (time) => {\n            measure(element, options.target, info)\n            updateScrollInfo(element, info, time)\n\n            if (options.offset || options.target) {\n                resolveOffsets(element, info, options)\n            }\n        },\n        notify: () => onScroll(info),\n    }\n}\n","import { cancelFrame, frame, frameData, resize } from \"motion-dom\"\nimport { noop } from \"motion-utils\"\nimport { createScrollInfo } from \"./info\"\nimport { createOnScrollHandler } from \"./on-scroll-handler\"\nimport { OnScrollHandler, OnScrollInfo, ScrollInfoOptions } from \"./types\"\n\nconst scrollListeners = new WeakMap<Element, VoidFunction>()\nconst resizeListeners = new WeakMap<Element, VoidFunction>()\nconst onScrollHandlers = new WeakMap<Element, Set<OnScrollHandler>>()\n\nexport type ScrollTargets = Array<HTMLElement>\n\nconst getEventTarget = (element: Element) =>\n    element === document.scrollingElement ? window : element\n\nexport function scrollInfo(\n    onScroll: OnScrollInfo,\n    {\n        container = document.scrollingElement as Element,\n        ...options\n    }: ScrollInfoOptions = {}\n) {\n    if (!container) return noop as VoidFunction\n\n    let containerHandlers = onScrollHandlers.get(container)\n\n    /**\n     * Get the onScroll handlers for this container.\n     * If one isn't found, create a new one.\n     */\n    if (!containerHandlers) {\n        containerHandlers = new Set()\n        onScrollHandlers.set(container, containerHandlers)\n    }\n\n    /**\n     * Create a new onScroll handler for the provided callback.\n     */\n    const info = createScrollInfo()\n    const containerHandler = createOnScrollHandler(\n        container,\n        onScroll,\n        info,\n        options\n    )\n    containerHandlers.add(containerHandler)\n\n    /**\n     * Check if there's a scroll event listener for this container.\n     * If not, create one.\n     */\n    if (!scrollListeners.has(container)) {\n        const measureAll = () => {\n            for (const handler of containerHandlers) {\n                handler.measure(frameData.timestamp)\n            }\n\n            frame.preUpdate(notifyAll)\n        }\n\n        const notifyAll = () => {\n            for (const handler of containerHandlers) {\n                handler.notify()\n            }\n        }\n\n        const listener = () => frame.read(measureAll)\n\n        scrollListeners.set(container, listener)\n\n        const target = getEventTarget(container)\n        window.addEventListener(\"resize\", listener, { passive: true })\n        if (container !== document.documentElement) {\n            resizeListeners.set(container, resize(container, listener))\n        }\n\n        target.addEventListener(\"scroll\", listener, { passive: true })\n\n        listener()\n    }\n\n    const listener = scrollListeners.get(container)!\n    frame.read(listener, false, true)\n\n    return () => {\n        cancelFrame(listener)\n\n        /**\n         * Check if we even have any handlers for this container.\n         */\n        const currentHandlers = onScrollHandlers.get(container)\n        if (!currentHandlers) return\n\n        currentHandlers.delete(containerHandler)\n\n        if (currentHandlers.size) return\n\n        /**\n         * If no more handlers, remove the scroll listener too.\n         */\n        const scrollListener = scrollListeners.get(container)\n        scrollListeners.delete(container)\n\n        if (scrollListener) {\n            getEventTarget(container).removeEventListener(\n                \"scroll\",\n                scrollListener\n            )\n            resizeListeners.get(container)?.()\n            window.removeEventListener(\"resize\", scrollListener)\n        }\n    }\n}\n","import { ProgressTimeline, supportsScrollTimeline } from \"motion-dom\"\nimport { scrollInfo } from \"../track\"\nimport { ScrollOptionsWithDefaults } from \"../types\"\n\ndeclare global {\n    interface Window {\n        ScrollTimeline: ScrollTimeline\n    }\n}\n\ndeclare class ScrollTimeline implements ProgressTimeline {\n    constructor(options: ScrollOptions)\n\n    currentTime: null | { value: number }\n\n    cancel?: VoidFunction\n}\n\nconst timelineCache = new Map<\n    Element,\n    Map<Element | \"self\", { x?: ProgressTimeline; y?: ProgressTimeline }>\n>()\n\nfunction scrollTimelineFallback(options: ScrollOptionsWithDefaults) {\n    const currentTime = { value: 0 }\n\n    const cancel = scrollInfo((info) => {\n        currentTime.value = info[options.axis!].progress * 100\n    }, options)\n\n    return { currentTime, cancel }\n}\n\nexport function getTimeline({\n    source,\n    container,\n    ...options\n}: ScrollOptionsWithDefaults): ProgressTimeline {\n    const { axis } = options\n\n    if (source) container = source\n\n    const containerCache = timelineCache.get(container) ?? new Map()\n    timelineCache.set(container, containerCache)\n\n    const targetKey = options.target ?? \"self\"\n    const targetCache = containerCache.get(targetKey) ?? {}\n\n    const axisKey = axis + (options.offset ?? []).join(\",\")\n\n    if (!targetCache[axisKey]) {\n        targetCache[axisKey] =\n            !options.target && supportsScrollTimeline()\n                ? new ScrollTimeline({ source: container, axis } as any)\n                : scrollTimelineFallback({ container, ...options })\n    }\n\n    return targetCache[axisKey]!\n}\n","import { AnimationPlaybackControls, observeTimeline } from \"motion-dom\"\nimport { ScrollOptionsWithDefaults } from \"./types\"\nimport { getTimeline } from \"./utils/get-timeline\"\n\nexport function attachToAnimation(\n    animation: AnimationPlaybackControls,\n    options: ScrollOptionsWithDefaults\n) {\n    const timeline = getTimeline(options)\n\n    return animation.attachTimeline({\n        timeline: options.target ? undefined : timeline,\n        observe: (valueAnimation) => {\n            valueAnimation.pause()\n\n            return observeTimeline((progress) => {\n                valueAnimation.time =\n                    valueAnimation.iterationDuration * progress\n            }, timeline)\n        },\n    })\n}\n","import { observeTimeline } from \"motion-dom\"\nimport { scrollInfo } from \"./track\"\nimport { OnScroll, OnScrollWithInfo, ScrollOptionsWithDefaults } from \"./types\"\nimport { getTimeline } from \"./utils/get-timeline\"\n\n/**\n * If the onScroll function has two arguments, it's expecting\n * more specific information about the scroll from scrollInfo.\n */\nfunction isOnScrollWithInfo(onScroll: OnScroll): onScroll is OnScrollWithInfo {\n    return onScroll.length === 2\n}\n\nexport function attachToFunction(\n    onScroll: OnScroll,\n    options: ScrollOptionsWithDefaults\n) {\n    if (isOnScrollWithInfo(onScroll)) {\n        return scrollInfo((info) => {\n            onScroll(info[options.axis!].progress, info)\n        }, options)\n    } else {\n        return observeTimeline(onScroll, getTimeline(options))\n    }\n}\n","import { AnimationPlaybackControls } from \"motion-dom\"\nimport { noop } from \"motion-utils\"\nimport { attachToAnimation } from \"./attach-animation\"\nimport { attachToFunction } from \"./attach-function\"\nimport { OnScroll, ScrollOptions } from \"./types\"\n\nexport function scroll(\n    onScroll: OnScroll | AnimationPlaybackControls,\n    {\n        axis = \"y\",\n        container = document.scrollingElement as Element,\n        ...options\n    }: ScrollOptions = {}\n): VoidFunction {\n    if (!container) return noop as VoidFunction\n\n    const optionsWithDefaults = { axis, container, ...options }\n\n    return typeof onScroll === \"function\"\n        ? attachToFunction(onScroll, optionsWithDefaults)\n        : attachToAnimation(onScroll, optionsWithDefaults)\n}\n","import { ElementOrSelector, resolveElements } from \"motion-dom\"\n\nexport type ViewChangeHandler = (entry: IntersectionObserverEntry) => void\n\ntype MarginValue = `${number}${\"px\" | \"%\"}`\ntype MarginType =\n    | MarginValue\n    | `${MarginValue} ${MarginValue}`\n    | `${MarginValue} ${MarginValue} ${MarginValue}`\n    | `${MarginValue} ${MarginValue} ${MarginValue} ${MarginValue}`\n\nexport interface InViewOptions {\n    root?: Element | Document\n    margin?: MarginType\n    amount?: \"some\" | \"all\" | number\n}\n\nconst thresholds = {\n    some: 0,\n    all: 1,\n}\n\nexport function inView(\n    elementOrSelector: ElementOrSelector,\n    onStart: (\n        element: Element,\n        entry: IntersectionObserverEntry\n    ) => void | ViewChangeHandler,\n    { root, margin: rootMargin, amount = \"some\" }: InViewOptions = {}\n): VoidFunction {\n    const elements = resolveElements(elementOrSelector)\n\n    const activeIntersections = new WeakMap<Element, ViewChangeHandler>()\n\n    const onIntersectionChange: IntersectionObserverCallback = (entries) => {\n        entries.forEach((entry) => {\n            const onEnd = activeIntersections.get(entry.target)\n\n            /**\n             * If there's no change to the intersection, we don't need to\n             * do anything here.\n             */\n            if (entry.isIntersecting === Boolean(onEnd)) return\n\n            if (entry.isIntersecting) {\n                const newOnEnd = onStart(entry.target, entry)\n                if (typeof newOnEnd === \"function\") {\n                    activeIntersections.set(entry.target, newOnEnd)\n                } else {\n                    observer.unobserve(entry.target)\n                }\n            } else if (typeof onEnd === \"function\") {\n                onEnd(entry)\n                activeIntersections.delete(entry.target)\n            }\n        })\n    }\n\n    const observer = new IntersectionObserver(onIntersectionChange, {\n        root,\n        rootMargin,\n        threshold: typeof amount === \"number\" ? amount : thresholds[amount],\n    })\n\n    elements.forEach((element) => observer.observe(element))\n\n    return () => observer.disconnect()\n}\n","import { cancelFrame, frame, FrameData, time } from \"motion-dom\"\nimport { secondsToMilliseconds } from \"motion-utils\"\n\nexport type DelayedFunction = (overshoot: number) => void\n\n/**\n * Timeout defined in ms\n */\nexport function delay(callback: DelayedFunction, timeout: number) {\n    const start = time.now()\n\n    const checkElapsed = ({ timestamp }: FrameData) => {\n        const elapsed = timestamp - start\n\n        if (elapsed >= timeout) {\n            cancelFrame(checkElapsed)\n            callback(elapsed - timeout)\n        }\n    }\n\n    frame.setup(checkElapsed, true)\n\n    return () => cancelFrame(checkElapsed)\n}\n\nexport function delayInSeconds(callback: DelayedFunction, timeout: number) {\n    return delay(callback, secondsToMilliseconds(timeout))\n}\n","import { Point } from \"motion-utils\"\n\nexport const distance = (a: number, b: number) => Math.abs(a - b)\n\nexport function distance2D(a: Point, b: Point): number {\n    // Multi-dimensional\n    const xDelta = distance(a.x, b.x)\n    const yDelta = distance(a.y, b.y)\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2)\n}\n"],"names":["resolveElements","removeItem","mixNumber","getEasingForSegment","defaultOffset","isGenerator","secondsToMilliseconds","createGeneratorEasing","fillOffset","invariant","isMotionValue","progress","motionValue","MotionGlobalConfig","transformProps","getValueTransition","makeAnimationInstant","frame","JSAnimation","AsyncMotionValueAnimation","positionalKeys","KeyframeResolver","time","checkIsControllingVariants","checkIsVariantNode","warnOnce","cancelFrame","isNumericalString","isZeroValueString","findValueType","complex","getAnimatableNone","SubscriptionManager","microtask","DOMKeyframesResolver","transformPropOrder","getValueAsType","numberValueTypes","isCSSVariableName","px","scrapeMotionValuesFromProps","getComputedStyle","defaultTransformValue","readTransformValue","scrapeHTMLMotionValuesFromProps","getDefaultValueType","isSVGElement","isSVGSVGElement","createMotionValue","spring","GroupAnimationWithThen","getAnimationMap","animationMapKey","fillWildcards","applyPxDefaults","NativeAnimation","velocityPerSecond","isHTMLElement","interpolate","clamp","noop","frameData","resize","supportsScrollTimeline","observeTimeline"],"mappings":"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"}