{"version":3,"file":"OutputBuffer.js","names":["isWhitespace","createOutputBuffer","_ref","write","chunkSize","bufferSize","buffer","offset","flushChunks","minSize","arguments","length","undefined","chunk","substring","flush","push","text","unshift","Error","flushedMessage","remove","start","end","insertAt","index","stripLastOccurrence","textToStrip","stripRemainingText","bufferIndex","lastIndexOf","insertBeforeLastWhitespace","textToInsert","endsWithIgnoringWhitespace","char","i","charAt"],"sources":["../../../../src/streaming/buffer/OutputBuffer.ts"],"sourcesContent":["import { isWhitespace } from '../../utils/stringUtils.js'\n\nexport interface OutputBuffer {\n  push: (text: string) => void\n  unshift: (text: string) => void\n  remove: (start: number, end?: number) => void\n  insertAt: (index: number, text: string) => void\n  length: () => number\n  flush: () => void\n\n  stripLastOccurrence: (textToStrip: string, stripRemainingText?: boolean) => void\n  insertBeforeLastWhitespace: (textToInsert: string) => void\n  endsWithIgnoringWhitespace: (char: string) => boolean\n}\n\nexport interface OutputBufferOptions {\n  write: (chunk: string) => void\n  chunkSize: number\n  bufferSize: number\n}\n\nexport function createOutputBuffer({\n  write,\n  chunkSize,\n  bufferSize\n}: OutputBufferOptions): OutputBuffer {\n  let buffer = ''\n  let offset = 0\n\n  function flushChunks(minSize = bufferSize) {\n    while (buffer.length >= minSize + chunkSize) {\n      const chunk = buffer.substring(0, chunkSize)\n      write(chunk)\n      offset += chunkSize\n      buffer = buffer.substring(chunkSize)\n    }\n  }\n\n  function flush() {\n    flushChunks(0)\n\n    if (buffer.length > 0) {\n      write(buffer)\n      offset += buffer.length\n      buffer = ''\n    }\n  }\n\n  function push(text: string) {\n    buffer += text\n    flushChunks()\n  }\n\n  function unshift(text: string) {\n    if (offset > 0) {\n      throw new Error(`Cannot unshift: ${flushedMessage}`)\n    }\n\n    buffer = text + buffer\n    flushChunks()\n  }\n\n  function remove(start: number, end?: number) {\n    if (start < offset) {\n      throw new Error(`Cannot remove: ${flushedMessage}`)\n    }\n\n    if (end !== undefined) {\n      buffer = buffer.substring(0, start - offset) + buffer.substring(end - offset)\n    } else {\n      buffer = buffer.substring(0, start - offset)\n    }\n  }\n\n  function insertAt(index: number, text: string) {\n    if (index < offset) {\n      throw new Error(`Cannot insert: ${flushedMessage}`)\n    }\n\n    buffer = buffer.substring(0, index - offset) + text + buffer.substring(index - offset)\n  }\n\n  function length(): number {\n    return offset + buffer.length\n  }\n\n  function stripLastOccurrence(textToStrip: string, stripRemainingText = false) {\n    const bufferIndex = buffer.lastIndexOf(textToStrip)\n\n    if (bufferIndex !== -1) {\n      if (stripRemainingText) {\n        buffer = buffer.substring(0, bufferIndex)\n      } else {\n        buffer =\n          buffer.substring(0, bufferIndex) + buffer.substring(bufferIndex + textToStrip.length)\n      }\n    }\n  }\n\n  function insertBeforeLastWhitespace(textToInsert: string) {\n    let bufferIndex = buffer.length // index relative to the start of the buffer, not taking `offset` into account\n\n    if (!isWhitespace(buffer, bufferIndex - 1)) {\n      // no trailing whitespaces\n      push(textToInsert)\n      return\n    }\n\n    while (isWhitespace(buffer, bufferIndex - 1)) {\n      bufferIndex--\n    }\n\n    if (bufferIndex <= 0) {\n      throw new Error(`Cannot insert: ${flushedMessage}`)\n    }\n\n    buffer = buffer.substring(0, bufferIndex) + textToInsert + buffer.substring(bufferIndex)\n    flushChunks()\n  }\n\n  function endsWithIgnoringWhitespace(char: string): boolean {\n    let i = buffer.length - 1\n\n    while (i > 0) {\n      if (char === buffer.charAt(i)) {\n        return true\n      }\n\n      if (!isWhitespace(buffer, i)) {\n        return false\n      }\n\n      i--\n    }\n\n    return false\n  }\n\n  return {\n    push,\n    unshift,\n    remove,\n    insertAt,\n    length,\n    flush,\n\n    stripLastOccurrence,\n    insertBeforeLastWhitespace,\n    endsWithIgnoringWhitespace\n  }\n}\n\nconst flushedMessage = 'start of the output is already flushed from the buffer'\n"],"mappings":"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","ignoreList":[]}